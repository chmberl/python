<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>查询 — Django 1.8.2 中文文档</title>
<link href="../../_static/default.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.8.2.dev20150513143415',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<link href="../../index.html" rel="top" title="Django 1.8.2.dev20150513143415 documentation"/>
<link href="index.html" rel="up" title="Models and databases"/>
<link href="aggregation.html" rel="next" title="Aggregation"/>
<link href="models.html" rel="prev" title="Models"/>
<script src="http://python.usyiyi.cn/django/templatebuiltins.js" type="text/javascript"></script>
<script type="text/javascript">
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='http://python.usyiyi.cn/django/topics/db/&quot;&#32;+&#32;base&#32;+&#32;&quot;#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='http://python.usyiyi.cn/django/topics/db/&quot;&#32;+&#32;base&#32;+&#32;&quot;#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);
</script>
</head>
<body>
<div class="document">
<div class="yui-t6" id="custom-doc">
<div id="hd">
<h1><font id="358">Django 1.8.2 文档</font></h1>
<div id="global-nav">
<a href="../../index.html" title="Home page">Home</a>  |
        <a href="../../contents.html" title="Table of contents">Table of contents</a>  |
        <a href="../../genindex.html" title="Global index">Index</a>  |
        <a href="../../py-modindex.html" title="Module index">Modules</a>
</div>
<div class="nav">
    « <a href="models.html" title="Models">previous</a>
     |
    <a accesskey="U" href="../index.html" title="Using Django">up</a>
   |
    <a href="aggregation.html" title="Aggregation">next</a> »</div>
</div>
<div id="bd">
<div id="yui-main">
<div class="yui-b">
<div class="yui-g" id="topics-db-queries">
<div class="section" id="s-making-queries">
<span id="making-queries"></span><h1><font id="359">执行查询</font><a class="headerlink" href="queries.html#making-queries" title="Permalink to this headline">¶</a></h1>
<p><font id="1">一旦你建立好<a class="reference internal" href="models.html"><em>数据模型</em></a>，Django 会自动为你生成一套数据库抽象的API，可以让你创建、检索、更新和删除对象。</font><font id="2">这篇文档阐述如何使用这些API。 </font><font id="3">关于所有模型查询选项的详细内容，请见<a class="reference internal" href="../../ref/models/index.html"><em>数据模型参考</em></a>。</font></p>
<p><font id="4">在整个文档（以及参考）中，我们将引用下面的模型，它构成一个博客应用：</font></p>
<div class="highlight-python" id="queryset-model-example"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>              <span class="c"># __unicode__ on Python 2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">EmailField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>              <span class="c"># __unicode__ on Python 2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">)</span>
    <span class="n">headline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="n">body_text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">pub_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">mod_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
    <span class="n">n_comments</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
    <span class="n">n_pingbacks</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
    <span class="n">rating</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>              <span class="c"># __unicode__ on Python 2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">headline</span>
</pre></div>
</div>
<div class="section" id="s-creating-objects">
<span id="creating-objects"></span><h2><font id="360">创建对象</font><a class="headerlink" href="queries.html#creating-objects" title="Permalink to this headline">¶</a></h2>
<p><font id="5">为了把数据库表中的数据表示成Python 对象，Django 使用一种直观的方式：一个模型类代表数据库中的一个表，一个模型类的实例代表这个数据库表中的一条特定的记录。</font></p>
<p><font id="6">使用关键字参数实例化模型实例来创建一个对象，然后调用<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 把它保存到数据库中。</font></p>
<p><font id="7">假设模型存放于文件<tt class="docutils literal"><span class="pre">mysite/blog/models.py</span></tt>中，下面是一个例子：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Beatles Blog'</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">'All the latest Beatles news.'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="8">上面的代码在背后执行了SQL 的<tt class="docutils literal"><span class="pre">INSERT</span></tt> 语句。</font><font id="9">在你显式调用<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>之前，Django 不会访问数据库。</font></p>
<p><font id="10"><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 方法没有返回值。</font></p>
<div class="admonition seealso">
<p class="first admonition-title"><font id="11">请参见</font></p>
<p><font id="12"><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>方法带有一些高级选项，它们没有在这里给出。</font><font id="13">完整的细节请见<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>&nbsp;文档。</font></p>
<p class="last"><font id="14">如果你想只用一条语句创建并保存一个对象，使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><tt class="xref py py-meth docutils literal"><span class="pre">create()</span></tt></a>方法。</font></p>
</div>
</div>
<div class="section" id="s-saving-changes-to-objects">
<span id="saving-changes-to-objects"></span><h2><font id="361">保存对象的改动</font><a class="headerlink" href="queries.html#saving-changes-to-objects" title="Permalink to this headline">¶</a></h2>
<p><font id="15">要保存对数据库中已存在的对象的改动，请使用<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>。</font></p>
<p><font id="16">假设<tt class="docutils literal"><span class="pre">Blog</span></tt> 的一个实例<tt class="docutils literal"><span class="pre">b5</span></tt> 已经被保存在数据库中，下面这个例子将更改它的名字并且更新数据库中的记录：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">'New name'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="17">上面的代码在背后执行SQL 的<tt class="docutils literal"><span class="pre">UPDATE</span></tt>语句。</font><font id="18">在你显式调用<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>之前，Django不会访问数据库。</font></p>
<div class="section" id="s-saving-foreignkey-and-manytomanyfield-fields">
<span id="saving-foreignkey-and-manytomanyfield-fields"></span><h3><font id="370">保存<tt class="docutils literal"><span class="pre">ForeignKey</span></tt>和<tt class="docutils literal"><span class="pre">ManyToManyField</span></tt>字段</font><a class="headerlink" href="queries.html#saving-foreignkey-and-manytomanyfield-fields" title="Permalink to this headline">¶</a></h3>
<p><font id="19">更新<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> 字段的方式和保存普通字段相同 —— 只要把一个正确类型的对象赋值给该字段。</font><font id="20">下面的例子更新<tt class="docutils literal"><span class="pre">Entry</span></tt> 实例<tt class="docutils literal"><span class="pre">entry</span></tt> 的<tt class="docutils literal"><span class="pre">blog</span></tt> 属性，假设<tt class="docutils literal"><span class="pre">Entry</span></tt> 和<tt class="docutils literal"><span class="pre">Blog</span></tt> 分别已经有一个正确的实例保存在数据库中（所以我们可以像下面这样获取它们）：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cheese_blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Cheddar Talk"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">cheese_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="21">更新<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a> 的方式有一些不同 —— 需要使用字段的<a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><tt class="xref py py-meth docutils literal"><span class="pre">add()</span></tt></a>方法来增加关联关系的一条记录。</font><font id="22">下面这个例子向<tt class="docutils literal"><span class="pre">entry</span></tt> 对象添加<tt class="docutils literal"><span class="pre">Author</span></tt> 类的实例<tt class="docutils literal"><span class="pre">joe</span></tt>：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Author</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">joe</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Joe"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">joe</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="23">为了在一条语句中，向<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a>添加多条记录，可以在调用<a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><tt class="xref py py-meth docutils literal"><span class="pre">add()</span></tt></a>方法时传入多个参数，像这样：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">john</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"John"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paul</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Paul"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">george</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"George"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringo</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Ringo"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">john</span><span class="p">,</span> <span class="n">paul</span><span class="p">,</span> <span class="n">george</span><span class="p">,</span> <span class="n">ringo</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="24">Django 将会在你赋值或添加错误类型的对象时报错。</font></p>
</div>
</div>
<div class="section" id="s-retrieving-objects">
<span id="s-id1"></span><span id="retrieving-objects"></span><span id="id1"></span><h2><font id="362">获取对象</font><a class="headerlink" href="queries.html#retrieving-objects" title="Permalink to this headline">¶</a></h2>
<p><font id="25">通过模型中的<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>构造一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，来从你的数据库中获取对象。</font></p>
<p><font id="26"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>表示从数据库中取出来的对象的集合。</font><font id="27">它可以含有零个、一个或者多个<em>过滤器</em>。</font><font id="28">过滤器根据所给的参数限制查询的结果。 </font><font id="29">从SQL 的角度，<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>和<tt class="docutils literal"><span class="pre">SELECT</span></tt> 语句等价，过滤器是像<tt class="docutils literal"><span class="pre">WHERE</span></tt> 和<tt class="docutils literal"><span class="pre">LIMIT</span></tt> 一样的限制子句。</font></p>
<p><font id="30">你可以从模型的<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>那里取得<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>。</font><font id="31">每个模型都至少有一个<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>，它默认命名为<a class="reference internal" href="../../ref/models/class.html#django.db.models.Model.objects" title="django.db.models.Model.objects"><tt class="xref py py-attr docutils literal"><span class="pre">objects</span></tt></a>。</font><font id="32">通过模型类来直接访问它，像这样：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span>
<span class="go">&lt;django.db.models.manager.Manager object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Foo'</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">'Bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">objects</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: "Manager isn't accessible via Blog instances."</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title"><font id="33">注</font></p>
<p class="last"><font id="34"><tt class="docutils literal"><span class="pre">管理器</span></tt>只可以通过模型的类访问，而不可以通过模型的实例访问，目的是为了强制区分“表级别”的操作和“记录级别”的操作。</font></p>
</div>
<p><font id="35">对于一个模型来说，<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>是<tt class="docutils literal"><span class="pre">查询集</span></tt>的主要来源。</font><font id="36">例如，<tt class="docutils literal"><span class="pre">Blog.objects.all()</span></tt> 返回包含数据库中所有<tt class="docutils literal"><span class="pre">Blog</span></tt> 对象的一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>。</font></p>
<div class="section" id="s-retrieving-all-objects">
<span id="retrieving-all-objects"></span><h3><font id="371">获取所有对象</font><a class="headerlink" href="queries.html#retrieving-all-objects" title="Permalink to this headline">¶</a></h3>
<p><font id="37">获取一个表中所有对象的最简单的方式是全部获取。</font><font id="38">可以使用<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><tt class="xref py py-meth docutils literal"><span class="pre">all()</span></tt></a> 方法：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">all_entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="39"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><tt class="xref py py-meth docutils literal"><span class="pre">all()</span></tt></a>方法返回包含数据库中所有对象的一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>。</font></p>
</div>
<div class="section" id="s-retrieving-specific-objects-with-filters">
<span id="retrieving-specific-objects-with-filters"></span><h3><font id="372">使用过滤器获取特定对象</font><a class="headerlink" href="queries.html#retrieving-specific-objects-with-filters" title="Permalink to this headline">¶</a></h3>
<p><font id="40"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><tt class="xref py py-meth docutils literal"><span class="pre">all()</span></tt></a> 方法返回的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>中包含数据库表中的全部对象。</font><font id="41">但是更普遍的情况是你需要获取完整集合的一个子集。</font></p>
<p><font id="42">要创建这样一个子集，你需要在原始的的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>上进行筛选，增加一些过滤器作为条件。</font><font id="43"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre"></span></tt></a>两个最普遍的途径是：</font></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">filter(**kwargs)</span></tt></dt>
<dd><font id="444">返回一个新的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，它包含满足查询参数的对象。</font></dd>
<dt><tt class="docutils literal"><span class="pre">exclude(**kwargs)</span></tt></dt>
<dd><font id="445">返回一个新的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，它包含<em>不</em>满足查询参数的对象。</font></dd>
</dl>
<p><font id="44">查询参数（上面函数定义中的<tt class="docutils literal"><span class="pre">**kwargs</span></tt>）需要满足特定的格式，<a class="reference internal" href="queries.html#field-lookups">字段检索</a>一节中会提到。</font></p>
<p><font id="45">举个例子，要获取年份为2006的所有文章的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，可以这样使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a>方法：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="46">利用默认的管理器，它相当于：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-chaining-filters">
<span id="s-id2"></span><span id="chaining-filters"></span><span id="id2"></span><h4><font id="393">链式过滤</font><a class="headerlink" href="queries.html#chaining-filters" title="Permalink to this headline">¶</a></h4>
<p><font id="47"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>的筛选结果本身还是<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，所以可以将筛选语句链接在一起。</font><font id="48">像这样：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">headline__startswith</span><span class="o">=</span><span class="s">'What'</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p><font id="49">这个例子最开始获取数据库中所有对象的一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，之后增加一个过滤器，然后又增加一个排除，再之后又是另外一个过滤器。</font><font id="50">最后的结果仍然是一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，它包含标题以”What“开头、发布日期在2005年1月30日至当天之间的所有记录。</font></p>
</div>
<div class="section" id="s-filtered-querysets-are-unique">
<span id="s-id3"></span><span id="filtered-querysets-are-unique"></span><span id="id3"></span><h4><font id="394">过滤后的查询集是独立的</font><a class="headerlink" href="queries.html#filtered-querysets-are-unique" title="Permalink to this headline">¶</a></h4>
<p><font id="51">每次你筛选一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，得到的都是全新的另一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，它和之前的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>之间没有任何绑定关系。</font><font id="52">每次筛选都会创建一个独立的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，它可以被存储及反复使用。</font></p>
<p><font id="53">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s">"What"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q3</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
</pre></div>
</div>
<p><font id="54">这三个<tt class="docutils literal"><span class="pre">查询集</span></tt>都是独立的。</font><font id="55">第一个是一个基础的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，包含所有标题以“What”开头的记录。</font><font id="56">第二个查询集是第一个的子集，它增加另外一个限制条件，排除<tt class="docutils literal"><span class="pre">pub_date</span></tt> 为今天和将来的记录。</font><font id="57">第三个查询集同样是第一个的子集，它增加另外一个限制条件，只选择<tt class="docutils literal"><span class="pre">pub_date</span></tt> 为今天或将来的记录。</font><font id="58">原始的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>(<tt class="docutils literal"><span class="pre">q1</span></tt>)不会受到筛选过程的影响。</font></p>
</div>
<div class="section" id="s-querysets-are-lazy">
<span id="s-id4"></span><span id="querysets-are-lazy"></span><span id="id4"></span><h4><font id="395">查询集是惰性执行的</font><a class="headerlink" href="queries.html#querysets-are-lazy" title="Permalink to this headline">¶</a></h4>
<p><font id="59"><tt class="docutils literal"><span class="pre">查询集</span></tt> 是惰性执行的 —— 创建<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>不会带来任何数据库的访问。</font><font id="60">你可以整天积压所有的过滤器在一起，Django 不会真正运行查询直到<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 需要<em>求值</em>时。</font><font id="61">看下这个例子：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s">"What"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">body_text__icontains</span><span class="o">=</span><span class="s">"food"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="62">虽然它看上去有三次数据库访问，但事实上只有在最后一行（<tt class="docutils literal"><span class="pre">print(q)</span></tt>）时才访问一次数据库。</font><font id="63">一般来说，只有在“请求”<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 的结果时才会到数据库中去获取它们。</font><font id="64">当你确实需要结果时，<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 通过访问数据库来<em>求值</em>。 </font><font id="65">关于求值发生的准确时间，参见 <a class="reference internal" href="../../ref/models/querysets.html#when-querysets-are-evaluated"><em>何时求值查询集</em></a>。</font></p>
</div>
</div>
<div class="section" id="s-retrieving-a-single-object-with-get">
<span id="s-retrieving-single-object-with-get"></span><span id="retrieving-a-single-object-with-get"></span><span id="retrieving-single-object-with-get"></span><h3><font id="373">通过get 获取一个单一的对象</font><a class="headerlink" href="queries.html#retrieving-a-single-object-with-get" title="Permalink to this headline">¶</a></h3>
<p><font id="66"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 始终给你一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，即使只有一个对象满足查询条件 —— 这种情况下，<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>将只包含一个元素。</font></p>
<p><font id="67">如果你知道只有一个对象满足你的查询，你可以使用<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 方法，它直接返回该对象：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">one_entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="68">可以对<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 使用任何查询表达式，和<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 一样 —— 同样请查看下文的<a class="reference internal" href="queries.html#field-lookups">字段查询</a>。</font></p>
<p><font id="69">注意，使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 和使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 的切片<tt class="docutils literal"><span class="pre">[0]</span></tt> 有一点区别。</font><font id="70">如果没有结果满足查询，<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 将引发一个<tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常。</font><font id="71">这个异常是正在查询的模型类的一个属性 —— 所以在上面的代码中，如果没有主键为1 的<tt class="docutils literal"><span class="pre">Entry</span></tt> 对象，Django 将引发一个<tt class="docutils literal"><span class="pre">Entry.DoesNotExist</span></tt>。</font></p>
<p><font id="72">类似地，如果有多条记录满足<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 的查询条件，Django 也将报错。</font><font id="73">这种情况将引发<a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><tt class="xref py py-exc docutils literal"><span class="pre">MultipleObjectsReturned</span></tt></a>，它同样是模型类自身的一个属性。</font></p>
</div>
<div class="section" id="s-other-queryset-methods">
<span id="other-queryset-methods"></span><h3><font id="374">其它查询集方法</font><a class="headerlink" href="queries.html#other-queryset-methods" title="Permalink to this headline">¶</a></h3>
<p><font id="74">大部分时候，当你需要从数据库中查找对象时，你将使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><tt class="xref py py-meth docutils literal"><span class="pre">all()</span></tt></a>、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>、<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 和<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><tt class="xref py py-meth docutils literal"><span class="pre">exclude()</span></tt></a>。 </font><font id="75">然而，这只是冰山一角；</font><font id="76"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>&nbsp;方法的完整列表，请参见<a class="reference internal" href="../../ref/models/querysets.html#queryset-api"><em>查询集API 参考</em></a>。</font></p>
</div>
<div class="section" id="s-limiting-querysets">
<span id="s-id5"></span><span id="limiting-querysets"></span><span id="id5"></span><h3><font id="375">限制查询集</font><a class="headerlink" href="queries.html#limiting-querysets" title="Permalink to this headline">¶</a></h3>
<p><font id="77">可以使用Python 的切片语法来限制<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 的结果。</font><font id="78">它等同于SQL 的<tt class="docutils literal"><span class="pre">LIMIT</span></tt> 和<tt class="docutils literal"><span class="pre">OFFSET</span></tt> 子句。</font></p>
<p><font id="79">例如，下面的语句返回前面5 个对象(<tt class="docutils literal"><span class="pre">LIMIT</span> <span class="pre">5</span></tt>)：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p><font id="80">下面这条语句返回第6 至第10 个对象(<tt class="docutils literal"><span class="pre">OFFSET</span> <span class="pre">5</span> <span class="pre">LIMIT</span> <span class="pre">5</span></tt>)：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p><font id="81">负的索引（例如<tt class="docutils literal"><span class="pre">Entry.objects.all()[-1]</span></tt>）不支持。</font></p>
<p><font id="82">通常，<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 的切片返回一个新的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> —— 它不会执行查询。</font><font id="83">有一个例外，是如果你使用Python 切片语法中"step"参数。</font><font id="84">例如，下面的语句将执行查询以对前10 个对象中返回每隔<em>2</em> 个的对象：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p><font id="85">若要获取一个<em>单一</em>的对象而不是一个列表（例如，<tt class="docutils literal"><span class="pre">SELECT</span> <span class="pre">foo</span> <span class="pre">FROM</span> <span class="pre">bar</span> <span class="pre">LIMIT</span> <span class="pre">1</span></tt>），可以简单地使用一个索引而不是切片。</font><font id="86">例如，下面的语句返回数据库中根据标题排序后的第一条<tt class="docutils literal"><span class="pre">Entry</span></tt>：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'headline'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p><font id="87">它大体等同于：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'headline'</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="88">然而请注意，如果没有对象满足给定的条件，第一条语句将引发<tt class="docutils literal"><span class="pre">IndexError</span></tt>而第二条语句将引发<tt class="docutils literal"><span class="pre">DoesNotExist</span></tt>。 </font><font id="89">更多细节参见<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>。</font></p>
</div>
<div class="section" id="s-field-lookups">
<span id="s-field-lookups-intro"></span><span id="field-lookups"></span><span id="field-lookups-intro"></span><h3><font id="376">字段查询</font><a class="headerlink" href="queries.html#field-lookups" title="Permalink to this headline">¶</a></h3>
<p><font id="90">字段查询是指如何指定SQL <tt class="docutils literal"><span class="pre">WHERE</span></tt> 子句的内容。</font><font id="91">它们通过<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>方法<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a>、<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><tt class="xref py py-meth docutils literal"><span class="pre">exclude()</span></tt></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 的关键字参数指定。</font></p>
<p><font id="92">查询的关键字参数的基本形式是<tt class="docutils literal"><span class="pre">field__lookuptype=value</span></tt>。</font><font id="93">（中间是两个下划线）。</font><font id="94">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="s">'2006-01-01'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="95">翻译成SQL（大体）是：</font></p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">blog_entry</span> <span class="k">WHERE</span> <span class="n">pub_date</span> <span class="o">&lt;=</span> <span class="s1">'2006-01-01'</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition-how-this-is-possible admonition">
<p class="first admonition-title"><font id="96">这是如何实现的</font></p>
<p class="last"><font id="97">Python 定义的函数可以接收任意的名/值对参数，这些名称和参数可以在运行时求值。</font><font id="98">更多信息，参见Python 官方文档中的<a class="reference external" href="https://docs.python.org/tutorial/controlflow.html#keyword-arguments">关键字参数</a>。</font></p>
</div>
<p><font id="99">查询条件中指定的字段必须是模型字段的名称。</font><font id="100">但有一个例外，对于<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a>你可以使用字段名加上<tt class="docutils literal"><span class="pre">_id</span></tt> 后缀。</font><font id="101">在这种情况下，该参数的值应该是外键的原始值。</font><font id="102">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog_id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="103">如果你传递的是一个不合法的参数，查询函数将引发 <tt class="docutils literal"><span class="pre">TypeError</span></tt>。</font></p>
<p><font id="104">这些数据库API 支持大约二十多中查询的类型；</font><font id="105">在<a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><em>字段查询参考</em></a> 中可以找到完整的参考。</font><font id="106">为了让你尝尝鲜，下面是一些你可能用到的常见查询：</font></p>
<dl class="docutils">
<dt><a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-exact"><tt class="xref std std-lookup docutils literal"><span class="pre">exact</span></tt></a></dt>
<dd><p class="first"><font id="107">“精确”匹配。</font><font id="108">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__exact</span><span class="o">=</span><span class="s">"Man bites dog"</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="109">将生成下面的SQL：</font></p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="o">=</span> <span class="s1">'Man bites dog'</span><span class="p">;</span>
</pre></div>
</div>
<p><font id="110">如果你没有提供查询类型 —— 即如果你的关键字参数不包含双下划线 —— 默认假定查询类型是<tt class="docutils literal"><span class="pre">exact</span></tt>。</font></p>
<p><font id="111">例如，下面的两条语句相等：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>         <span class="c"># __exact is implied</span>
</pre></div>
</div>
<p class="last"><font id="112">这是为了方便，因为<tt class="docutils literal"><span class="pre">exact</span></tt> 查询是最常见的情况。</font></p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-iexact"><tt class="xref std std-lookup docutils literal"><span class="pre">iexact</span></tt></a></dt>
<dd><p class="first"><font id="113">大小写不敏感的匹配。</font><font id="114">所以，查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s">"beatles blog"</span><span class="p">)</span>
</pre></div>
</div>
<p class="last"><font id="115">将匹配标题为<tt class="docutils literal"><span class="pre">"Beatles</span> <span class="pre">Blog"</span></tt>、<tt class="docutils literal"><span class="pre">"beatles</span> <span class="pre">blog"</span></tt> 甚至<tt class="docutils literal"><span class="pre">"BeAtlES</span> <span class="pre">blOG"</span></tt> 的<tt class="docutils literal"><span class="pre">Blog</span></tt>。</font></p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-contains"><tt class="xref std std-lookup docutils literal"><span class="pre">contains</span></tt></a></dt>
<dd><p class="first"><font id="116">大小写敏感的包含关系测试。</font><font id="117">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="118">大体可以翻译成下面的SQL：</font></p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">'%Lennon%'</span><span class="p">;</span>
</pre></div>
</div>
<p><font id="119">注意，这将匹配<tt class="docutils literal"><span class="pre">'Today</span> <span class="pre">Lennon</span> <span class="pre">honored'</span></tt> 但不能匹配<tt class="docutils literal"><span class="pre">'today</span> <span class="pre">lennon</span> <span class="pre">honored'</span></tt>。</font></p>
<p class="last"><font id="120">还有一个大小写不敏感的版本，<a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-icontains"><tt class="xref std std-lookup docutils literal"><span class="pre">icontains</span></tt></a>。</font></p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-startswith"><tt class="xref std std-lookup docutils literal"><span class="pre">startswith</span></tt></a>, <a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-endswith"><tt class="xref std std-lookup docutils literal"><span class="pre">endswith</span></tt></a></dt>
<dd><font id="446">分别表示以XXX开头和以XXX结尾。</font><font id="447">当然还有大小写不敏感的版本，叫做<a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-istartswith"><tt class="xref std std-lookup docutils literal"><span class="pre">istartswith</span></tt></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-iendswith"><tt class="xref std std-lookup docutils literal"><span class="pre">iendswith</span></tt></a>。</font></dd>
</dl>
<p><font id="121">同样，这里只是表面。</font><font id="122">完整的参考可以在<a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><em>字段查询参考</em></a>中找到。</font></p>
</div>
<div class="section" id="s-lookups-that-span-relationships">
<span id="s-id6"></span><span id="lookups-that-span-relationships"></span><span id="id6"></span><h3><font id="377">跨关联关系的查询</font><a class="headerlink" href="queries.html#lookups-that-span-relationships" title="Permalink to this headline">¶</a></h3>
<p><font id="123">Django 提供一种强大而又直观的方式来“处理”查询中的关联关系，它在后台自动帮你处理<tt class="docutils literal"><span class="pre">JOIN</span></tt>。 </font><font id="124">若要跨越关联关系，只需使用关联的模型字段的名称，并使用双下划线分隔，直至你想要的字段：</font></p>
<p><font id="125">下面这个例子获取所有<tt class="docutils literal"><span class="pre">Blog</span></tt> 的<tt class="docutils literal"><span class="pre">name</span></tt> 为<tt class="docutils literal"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></tt> 的<tt class="docutils literal"><span class="pre">Entry</span></tt> 对象：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name</span><span class="o">=</span><span class="s">'Beatles Blog'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="126">这种跨越可以是任意的深度。</font></p>
<p><font id="127">它还可以反向工作。</font><font id="128">若要引用一个“反向”的关系，只需要使用该模型的小写的名称。</font></p>
<p><font id="129">下面的示例获取所有的<tt class="docutils literal"><span class="pre">Blog</span></tt> 对象，它们至少有一个<tt class="docutils literal"><span class="pre">Entry</span></tt> 的<tt class="docutils literal"><span class="pre">headline</span></tt> 包含<tt class="docutils literal"><span class="pre">'Lennon'</span></tt>：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="130">如果你在多个关联关系直接过滤而且其中某个中介模型没有满过滤条件的值，Django 将把它当做一个空的（所有的值都为<tt class="docutils literal"><span class="pre">NULL</span></tt>）但是合法的对象。</font><font id="131">这意味着不会有错误引发。</font><font id="132">例如，在下面的过滤器中：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="133">（如果有一个相关联的<tt class="docutils literal"><span class="pre">Author</span></tt> 模型），如果没有Entry 中没有找到对应的<tt class="docutils literal"><span class="pre">author</span></tt>，那么它将当作其没有<tt class="docutils literal"><span class="pre">name</span></tt>，而不会因为没有<tt class="docutils literal"><span class="pre">author</span></tt> 引发一个错误。</font><font id="134">通常，这就是你想要的。</font><font id="135">唯一可能让你困惑的是当你使用<a class="reference internal" href="../../ref/models/querysets.html#std:fieldlookup-isnull"><tt class="xref std std-lookup docutils literal"><span class="pre">isnull</span></tt></a> 的时候。</font><font id="136">因此：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="137">返回的<tt class="docutils literal"><span class="pre">Blog</span></tt> 对象包括具有<tt class="docutils literal"><span class="pre">name</span></tt> 为空的<tt class="docutils literal"><span class="pre">author</span></tt> 和具有<tt class="docutils literal"><span class="pre">author</span></tt> 为空的<tt class="docutils literal"><span class="pre">entry</span></tt>。</font><font id="138">如果你不需要后者，你可以这样写：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__isnull</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-spanning-multi-valued-relationships">
<span id="spanning-multi-valued-relationships"></span><h4><font id="396">跨越多值的关联关系</font><a class="headerlink" href="queries.html#spanning-multi-valued-relationships" title="Permalink to this headline">¶</a></h4>
<p><font id="139">当你基于<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a> 或反向的<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> 来过滤一个对象时，有两种不同种类的过滤器。</font><font id="140">考虑<tt class="docutils literal"><span class="pre">Blog</span></tt>/<tt class="docutils literal"><span class="pre">Entry</span></tt> 关联关系（<tt class="docutils literal"><span class="pre">Blog</span></tt> 和 <tt class="docutils literal"><span class="pre">Entry</span></tt> 是一对多的关系）。</font><font id="141">我们可能想找出标题行中包含<em>“Lennon”</em> 且在2008 年发布的Entry。</font><font id="142">或者我们可能想找出这样的Blog，它包含一个标题行具有<em>“Lennon”</em> 的Entry和一个在2008 发布的Entry。</font><font id="143">因为实际上有和单个<tt class="docutils literal"><span class="pre">Blog</span></tt> 相关联的多个Entry，所以这两个查询在某些场景下都是有可能并有意义的。</font></p>
<p><font id="144"><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a> 有类似的情况。</font><font id="145">例如，如果<tt class="docutils literal"><span class="pre">Entry</span></tt> 有一个<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a> 叫做 <tt class="docutils literal"><span class="pre">tags</span></tt>，我们可能想找到tag 叫做<em>“music”</em> 和<em>“bands”</em> 的Entry，或者我们想找一个tags 名为<em>“music”</em> 且状态为<em>“public”</em>的Entry。</font></p>
<p><font id="146">对于这两种情况，Django 有种一致的方法来处理<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 调用。</font><font id="147">单个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 调用中的所有内容都会立即执行以筛选出满足所有要求的记录。</font><font id="148">接下来的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 调用进一步限制对象集，但是对于多值关系，它们应用到所有与住模型关联的对象，而不必应用到通过前面的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 调用选择出来的对象。</font></p>
<p><font id="149">这些听起来可能有点混乱，所以希望展示一个例子使它变得更清晰</font><font id="150">To select all blogs that contain entries with both <em>“Lennon”</em> in the headline and that were published in 2008 (the same entry satisfying both conditions), we would write:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">,</span>
        <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="151">To select all blogs that contain an entry with <em>“Lennon”</em> in the headline <strong>as well as</strong> an entry that was published in 2008, we would write:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="152">Suppose there is only one blog that had both entries containing <em>“Lennon”</em> and entries from 2008, but that none of the entries from 2008 contained <em>“Lennon”</em>. </font><font id="153">The first query would not return any blogs, but the second query would return that one blog.</font></p>
<p><font id="154">In the second example, the first filter restricts the queryset to all those blogs linked to entries with <em>“Lennon”</em> in the headline. </font><font id="155">The second filter restricts the set of blogs <em>further</em> to those that are also linked to entries that were published in 2008. </font><font id="156">The entries selected by the second filter may or may not be the same as the entries in the first filter. </font><font id="157">We are filtering the <tt class="docutils literal"><span class="pre">Blog</span></tt> items with each filter statement, not the <tt class="docutils literal"><span class="pre">Entry</span></tt> items.</font></p>
<div class="admonition note">
<p class="first admonition-title"><font id="158">注</font></p>
<p><font id="159">跨越多值关系的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 查询的行为，与<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><tt class="xref py py-meth docutils literal"><span class="pre">exclude()</span></tt></a> 实现的不同。</font><font id="160">单个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><tt class="xref py py-meth docutils literal"><span class="pre">exclude()</span></tt></a> 调用中的条件不必引用同一个记录。</font></p>
<p><font id="161">例如，下面的查询排除<em></em>headline 中包含<em>“Lennon”</em>的Entry<em>和</em>在2008 年发布的Entry：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">,</span>
    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p><font id="162">然而，这与使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 的行为不同，它不是排除同时满足两个条件的Entry。</font><font id="163">为了实现这点，即选择的Blog中不包含在2008年发布且healine 中带有<em>“Lennon”</em> 的Entry，你需要编写两个查询：</font></p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry</span><span class="o">=</span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">,</span>
        <span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="s-filters-can-reference-fields-on-the-model">
<span id="s-using-f-expressions-in-filters"></span><span id="filters-can-reference-fields-on-the-model"></span><span id="using-f-expressions-in-filters"></span><h3><font id="378">过滤器可以引用模型的字段</font><a class="headerlink" href="queries.html#filters-can-reference-fields-on-the-model" title="Permalink to this headline">¶</a></h3>
<p><font id="164">到目前为止给出的示例中，我们构造过将模型字段与常量进行比较的过滤器。</font><font id="165">但是，如果你想将模型的一个字段与同一个模型的另外一个字段进行比较该怎么办？</font></p>
<p><font id="166">Django 提供<a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><tt class="xref py py-class docutils literal"><span class="pre">F</span> <span class="pre">表达式</span></tt></a> 来允许这样的比较。</font><font id="167"><tt class="docutils literal"><span class="pre">F()</span></tt> 返回的实例用作对查询中的模型字段的引用。</font><font id="168">这些引用可以用于查询的过滤器中来比较相同模型实例上不同字段之间值的比较。</font></p>
<p><font id="169">例如，为了查找comments 数目多于pingbacks 的Entry，我们将构造一个<tt class="docutils literal"><span class="pre">F()</span></tt> 对象来引用pingback 数目，并在查询中使用该<tt class="docutils literal"><span class="pre">F()</span></tt> 对象：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">n_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">'n_pingbacks'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="170">Django 支持对<tt class="docutils literal"><span class="pre">F()</span></tt> 对象使用加法、减法、乘法、除法、取模以及幂计算等算术操作，两个操作数可以都是常数和其它<tt class="docutils literal"><span class="pre">F()</span></tt> 对象。</font><font id="171">为了查找comments 数目比pingbacks <em>两倍</em>还要多的Entry，我们将查询修改为：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">n_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">'n_pingbacks'</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<span class="title">New in Django 1.7:</span> <p><font id="172">添加 <tt class="docutils literal"><span class="pre">**</span></tt> 操作符。</font></p>
</div>
<p><font id="173">为了查询rating 比pingback 和comment 数目总和要小的Entry，我们将这样查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">rating__lt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">'n_comments'</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="s">'n_pingbacks'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="174">你还可以在<tt class="docutils literal"><span class="pre">F()</span></tt> 对象中使用双下划线标记来跨越关联关系。</font><font id="175">带有双下划线的<tt class="docutils literal"><span class="pre">F()</span></tt> 对象将引入需要的join 操作以访问关联的对象。</font><font id="176">例如，如要获取author 的名字与blog 名字相同的Entry，我们可以这样查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">authors__name</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">'blog__name'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="177">对于date 和date/time 字段，你可以给它们加上或减去一个<a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.4)"><tt class="xref py py-class docutils literal"><span class="pre">timedelta</span></tt></a> 对象。</font><font id="178">下面的例子将返回发布超过3天后被修改的所有Entry：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mod_date__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">)</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="179"><tt class="docutils literal"><span class="pre">F()</span></tt> 对象支持<tt class="docutils literal"><span class="pre">.bitand()</span></tt> 和<tt class="docutils literal"><span class="pre">.bitor()</span></tt> 两种位操作，例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">(</span><span class="s">'somefield'</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-the-pk-lookup-shortcut">
<span id="the-pk-lookup-shortcut"></span><h3><font id="379">查询的快捷方式pk</font><a class="headerlink" href="queries.html#the-pk-lookup-shortcut" title="Permalink to this headline">¶</a></h3>
<p><font id="180">为了方便，Django 提供一个查询快捷方式<tt class="docutils literal"><span class="pre">pk</span></tt> ，它表示“primary key” 的意思。</font></p>
<p><font id="181">在<tt class="docutils literal"><span class="pre">Blog</span></tt> 模型示例中，主键是<tt class="docutils literal"><span class="pre">id</span></tt> 字段，所以下面三条语句是等同的：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span> <span class="c"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span> <span class="c"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span> <span class="c"># pk implies id__exact</span>
</pre></div>
</div>
<p><font id="182"><tt class="docutils literal"><span class="pre">pk</span></tt> 的使用不仅限于<tt class="docutils literal"><span class="pre">__exact</span></tt> 查询 —— 任何查询类型都可以与<tt class="docutils literal"><span class="pre">pk</span></tt> 结合来完成一个模型上对主键的查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre># Get blogs entries with id 1, 4 and 7
&gt;&gt;&gt; Blog.objects.filter(pk__in=[1,4,7])

# Get all blog entries with id &gt; 14
&gt;&gt;&gt; Blog.objects.filter(pk__gt=14)
</pre></div>
</div>
<p><font id="183"><tt class="docutils literal"><span class="pre">pk</span></tt>查询在join 中也可以工作。</font><font id="184">例如，下面三个语句是等同的：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id__exact</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__pk</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># __pk implies __id__exact</span>
</pre></div>
</div>
</div>
<div class="section" id="s-escaping-percent-signs-and-underscores-in-like-statements">
<span id="escaping-percent-signs-and-underscores-in-like-statements"></span><h3><font id="380">转义LIKE 语句中的百分号和下划线</font><a class="headerlink" href="queries.html#escaping-percent-signs-and-underscores-in-like-statements" title="Permalink to this headline">¶</a></h3>
<p><font id="185">与<tt class="docutils literal"><span class="pre">LIKE</span></tt> SQL 语句等同的字段查询（<tt class="docutils literal"><span class="pre">iexact</span></tt>、 <tt class="docutils literal"><span class="pre">contains</span></tt>、<tt class="docutils literal"><span class="pre">icontains</span></tt>、<tt class="docutils literal"><span class="pre">startswith</span></tt>、 <tt class="docutils literal"><span class="pre">istartswith</span></tt>、<tt class="docutils literal"><span class="pre">endswith</span></tt> 和<tt class="docutils literal"><span class="pre">iendswith</span></tt>）将自动转义在<tt class="docutils literal"><span class="pre">LIKE</span></tt> 语句中使用的两个特殊的字符 —— 百分号和下划线。</font><font id="186">（在<tt class="docutils literal"><span class="pre">LIKE</span></tt> 语句中，百分号通配符表示多个字符，下划线通配符表示单个字符）。</font></p>
<p><font id="187">这意味着语句将很直观，&nbsp;so the abstraction doesn’t leak。</font><font id="188">例如，要获取包含一个百分号的所有的Entry，只需要像其它任何字符一样使用百分号：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">'%'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="189">Django 会帮你转义；</font><font id="190">生成的SQL 看上去会是这样：</font></p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">'%\%%'</span><span class="p">;</span>
</pre></div>
</div>
<p><font id="191">对于下划线是同样的道理。</font><font id="192">百分号和下划线都会透明底帮你处理。</font></p>
</div>
<div class="section" id="s-caching-and-querysets">
<span id="s-id7"></span><span id="caching-and-querysets"></span><span id="id7"></span><h3><font id="381">缓存和查询集</font><a class="headerlink" href="queries.html#caching-and-querysets" title="Permalink to this headline">¶</a></h3>
<p><font id="193">每个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>都包含一个缓存来最小化对数据库的访问。</font><font id="194">理解它是如何工作的将让你编写最高效的代码。</font></p>
<p><font id="195">在一个新创建的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>中，缓存为空。</font><font id="196">首次对<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>进行求值 —— 同时发生数据库查询 ——Django 将保存查询的结果到<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>的缓存中并返回明确请求的结果（例如，如果正在迭代<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，则返回下一个结果）。</font><font id="197">接下来对该<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 的求值将重用缓存的结果。</font></p>
<p><font id="198">要记住这个缓存行为，如果<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>使用不当，它会咬你的。</font><font id="199">例如，下面的语句创建两个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>，对它们求值，然后扔掉它们：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
</pre></div>
</div>
<p><font id="200">这意味着相同的数据库查询将执行两次，显然倍增了你的数据库负载。</font><font id="201">同时，还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有<tt class="docutils literal"><span class="pre">Entry</span></tt>被添加进来或删除掉。</font></p>
<p><font id="202">为了避免这个问题，只需保存<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>并重新使用它：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span> <span class="c"># Evaluate the query set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span> <span class="c"># Re-use the cache from the evaluation.</span>
</pre></div>
</div>
<div class="section" id="s-when-querysets-are-not-cached">
<span id="when-querysets-are-not-cached"></span><h4><font id="397">何时查询集不会被缓存</font><a class="headerlink" href="queries.html#when-querysets-are-not-cached" title="Permalink to this headline">¶</a></h4>
<p><font id="203">查询集不会永远缓存它们的结果。</font><font id="204">当只对查询集的<em>部分</em> 进行求值时会检查缓存， 但是如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。</font><font id="205">特别地，这意味着使用切片或索引来<a class="reference internal" href="queries.html#limiting-querysets"><em>限制查询集</em></a>将不会填充缓存。</font></p>
<p><font id="206">例如，重复获取查询集对象中一个特定的索引将每次都查询数据库：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="c"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="c"># Queries the database again</span>
</pre></div>
</div>
<p><font id="207">然而，如果已经对全部查询集求值过，则将检查缓存：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span> <span class="c"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="c"># Uses cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="c"># Uses cache</span>
</pre></div>
</div>
<p><font id="208">下面是一些其它例子，它们会使得全部的查询集被求值并填充到缓存中：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title"><font id="209">注</font></p>
<p class="last"><font id="210">简单地打印查询集不会填充缓存。</font><font id="211">因为<tt class="docutils literal"><span class="pre">__repr__()</span></tt> 调用只返回全部查询集的一个切片。</font></p>
</div>
</div>
</div>
</div>
<div class="section" id="s-complex-lookups-with-q-objects">
<span id="s-complex-lookups-with-q"></span><span id="complex-lookups-with-q-objects"></span><span id="complex-lookups-with-q"></span><h2><font id="363">使用Q 对象进行复杂的查询</font><a class="headerlink" href="queries.html#complex-lookups-with-q-objects" title="Permalink to this headline">¶</a></h2>
<p><font id="212"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a> 等方法中的关键字参数查询都是一起进行“AND” 的。 </font><font id="213">如果你需要执行更复杂的查询（例如<tt class="docutils literal"><span class="pre">OR</span></tt> 语句），你可以使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><tt class="xref py py-class docutils literal"><span class="pre">Q</span> <span class="pre">对象</span></tt></a>。</font></p>
<p><font id="214"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><tt class="xref py py-class docutils literal"><span class="pre">Q</span> <span class="pre"> 对象</span></tt></a> (<tt class="docutils literal"><span class="pre">django.db.models.Q</span></tt>) 对象用于封装一组关键字参数。</font><font id="215">这些关键字参数就是上文“字段查询” 中所提及的那些。</font></p>
<p><font id="216">例如，下面的<tt class="docutils literal"><span class="pre">Q</span></tt> 对象封装一个<tt class="docutils literal"><span class="pre">LIKE</span></tt> 查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Q</span>
<span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">'What'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="217"><tt class="docutils literal"><span class="pre">Q</span></tt> 对象可以使用<tt class="docutils literal"><span class="pre">&amp;</span></tt> 和<tt class="docutils literal"><span class="pre">|</span></tt> 操作符组合起来。</font><font id="218">当一个操作符在两个<tt class="docutils literal"><span class="pre">Q</span></tt> 对象上使用时，它产生一个新的<tt class="docutils literal"><span class="pre">Q</span></tt> 对象。</font></p>
<p><font id="219">例如，下面的语句产生一个<tt class="docutils literal"><span class="pre">Q</span></tt> 对象，表示两个<tt class="docutils literal"><span class="pre">"question__startswith"</span></tt> 查询的“OR” ：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">'Who'</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">'What'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="220">它等同于下面的SQL <tt class="docutils literal"><span class="pre">WHERE</span></tt> 子句：</font></p>
<div class="highlight-python"><div class="highlight"><pre>WHERE question LIKE 'Who%' OR question LIKE 'What%'
</pre></div>
</div>
<p><font id="221">你可以组合<tt class="docutils literal"><span class="pre">&amp;</span></tt> 和<tt class="docutils literal"><span class="pre">|</span></tt> &nbsp;操作符以及使用括号进行分组来编写任意复杂的<tt class="docutils literal"><span class="pre">Q</span></tt> 对象。</font><font id="222">同时，<tt class="docutils literal"><span class="pre">Q</span></tt> 对象可以使用<tt class="docutils literal"><span class="pre">~</span></tt> 操作符取反，这允许组合正常的查询和取反(<tt class="docutils literal"><span class="pre">NOT</span></tt>) 查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">'Who'</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">Q</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="223">每个接受关键字参数的查询函数（例如<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt></a>、<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><tt class="xref py py-meth docutils literal"><span class="pre">exclude()</span></tt></a>、<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>）还可以被传递一个或多个<tt class="docutils literal"><span class="pre">Q</span></tt> 对象作为位置（不带名的）参数。</font><font id="224">如果你提供多个<tt class="docutils literal"><span class="pre">Q</span></tt> 对象参数给一个查询函数，这些参数将会"AND"在一起。</font><font id="225">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">'Who'</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
<p><font id="226">... 大体上可以翻译成这个SQL：</font></p>
<div class="highlight-python"><div class="highlight"><pre>SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')
</pre></div>
</div>
<p><font id="227">查询函数可以混合使用<tt class="docutils literal"><span class="pre">Q 对象</span></tt>和关键字参数。</font><font id="228">所有提供给查询函数的参数（关键字参数或<tt class="docutils literal"><span class="pre">Q</span></tt> 对象）都将"AND”在一起。</font><font id="229">但是，如果出现<tt class="docutils literal"><span class="pre">Q</span></tt> 对象，它必须位于所有关键字参数的前面。</font><font id="230">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s">'Who'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="231">... 是一个合法的查询，等同于前面的例子；</font><font id="232">但是：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># INVALID QUERY</span>
<span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s">'Who'</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
</pre></div>
</div>
<p><font id="233">... 是不合法的。</font></p>
<div class="admonition seealso">
<p class="first admonition-title"><font id="234">另见</font></p>
<p class="last"><font id="235">Django 单元测试中的<a class="reference external" href="https://github.com/django/django/blob/master/tests/or_lookups/tests.py">OR 查询示例</a>演示了几种<tt class="docutils literal"><span class="pre">Q</span></tt> 的用法。</font></p>
</div>
</div>
<div class="section" id="s-comparing-objects">
<span id="comparing-objects"></span><h2><font id="364">比较对象</font><a class="headerlink" href="queries.html#comparing-objects" title="Permalink to this headline">¶</a></h2>
<p><font id="236">为了比较两个模型实例，只需要使用标准的Python 比较操作符，即双等于符号：<tt class="docutils literal"><span class="pre">==</span></tt>。</font><font id="237">在后台，它会比较两个模型主键的值。</font></p>
<p><font id="238">利用上面的<tt class="docutils literal"><span class="pre">Entry</span></tt> 示例，下面两个语句是等同的：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span> <span class="o">==</span> <span class="n">other_entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other_entry</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p><font id="239">如同模型的主键不叫<tt class="docutils literal"><span class="pre">id</span></tt>，也没有问题。</font><font id="240">比较将始终使用主键，无论它叫什么。</font><font id="241">例如，如果模型的主键字段叫做<tt class="docutils literal"><span class="pre">name</span></tt>，下面的两条语句是等同的：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span> <span class="o">==</span> <span class="n">other_obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
<div class="section" id="s-deleting-objects">
<span id="s-topics-db-queries-delete"></span><span id="deleting-objects"></span><span id="topics-db-queries-delete"></span><h2><font id="365">删除对象</font><a class="headerlink" href="queries.html#deleting-objects" title="Permalink to this headline">¶</a></h2>
<p><font id="242">删除方法，为了方便，就取名为<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><tt class="xref py py-meth docutils literal"><span class="pre">delete()</span></tt></a>。</font><font id="243">这个方法将立即删除对象且没有返回值。</font><font id="244">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="245">你还可以批量删除对象。</font><font id="246">每个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 都有一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><tt class="xref py py-meth docutils literal"><span class="pre">delete()</span></tt></a> 方法，它将删除该<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>中的所有成员。</font></p>
<p><font id="247">例如，下面的语句删除<tt class="docutils literal"><span class="pre">pub_date</span></tt> 为2005 的所有<tt class="docutils literal"><span class="pre">Entry</span></tt> 对象：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="248">记住，这将尽可能地使用纯SQL 执行，所以这个过程中不需要调用每个对象实例的<tt class="docutils literal"><span class="pre">delete()</span></tt>方法。</font><font id="249">如果你给模型类提供了一个自定义的<tt class="docutils literal"><span class="pre">delete()</span></tt> 方法并希望确保它被调用，你需要手工删除该模型的实例（例如，迭代<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>并调用每个对象的<tt class="docutils literal"><span class="pre">delete()</span></tt>）而不能使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>的批量<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><tt class="xref py py-meth docutils literal"><span class="pre">delete()</span></tt></a> 方法。</font></p>
<p><font id="250">当Django 删除一个对象时，它默认使用SQL <tt class="docutils literal"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></tt> 约束 —— 换句话讲，任何有外键指向要删除对象的对象将一起删除。</font><font id="251">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># This will delete the Blog and all of its Entry objects.</span>
<span class="n">b</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="252">这种级联的行为可以通过的<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> 的<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><tt class="xref py py-attr docutils literal"><span class="pre">on_delete</span></tt></a> 参数自定义。</font></p>
<p><font id="253">注意，<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><tt class="xref py py-meth docutils literal"><span class="pre">delete()</span></tt></a> 是唯一没有在<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a> 上暴露出来的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>方法。</font><font id="254">这是一个安全机制来防止你意外地请求<tt class="docutils literal"><span class="pre">Entry.objects.delete()</span></tt>，而删除<em>所有</em> 的条目。</font><font id="255">如果你<em>确实</em>想删除所有的对象，你必须明确地请求一个完全的查询集：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-copying-model-instances">
<span id="s-topics-db-queries-copy"></span><span id="copying-model-instances"></span><span id="topics-db-queries-copy"></span><h2><font id="366">拷贝模型实例</font><a class="headerlink" href="queries.html#copying-model-instances" title="Permalink to this headline">¶</a></h2>
<p><font id="256">虽然没有内建的方法用于拷贝模型实例，但还是很容易创建一个新的实例并让它的所有字段都拷贝过来。</font><font id="257">最简单的方法是，只需要将<tt class="docutils literal"><span class="pre">pk</span></tt> 设置为<tt class="docutils literal"><span class="pre">None</span></tt>。</font><font id="258">利用我们的Blog 示例：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'My blog'</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">'Blogging is easy'</span><span class="p">)</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="c"># blog.pk == 1</span>

<span class="n">blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="c"># blog.pk == 2</span>
</pre></div>
</div>
<p><font id="259">如果你用继承，那么会复杂一些。</font><font id="260">考虑下面<tt class="docutils literal"><span class="pre">Blog</span></tt> 的子类：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ThemeBlog</span><span class="p">(</span><span class="n">Blog</span><span class="p">):</span>
    <span class="n">theme</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="n">django_blog</span> <span class="o">=</span> <span class="n">ThemeBlog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Django'</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">'Django is easy'</span><span class="p">,</span> <span class="n">theme</span><span class="o">=</span><span class="s">'python'</span><span class="p">)</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="c"># django_blog.pk == 3</span>
</pre></div>
</div>
<p><font id="261">由于继承的工作方式，你必须设置<tt class="docutils literal"><span class="pre">pk</span></tt> 和 <tt class="docutils literal"><span class="pre">id</span></tt> 都为None：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">django_blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="c"># django_blog.pk == 4</span>
</pre></div>
</div>
<p><font id="262">这个过程不会拷贝关联的对象。</font><font id="263">如果你想拷贝关联关系，你必须编写一些更多的代码。</font><font id="264">在我们的例子中，<tt class="docutils literal"><span class="pre">Entry</span></tt> 有一个到<tt class="docutils literal"><span class="pre">Author</span></tt> 的多对多字段：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="c"># some previous entry</span>
<span class="n">old_authors</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">authors</span> <span class="o">=</span> <span class="n">old_authors</span> <span class="c"># saves new many2many relations</span>
</pre></div>
</div>
</div>
<div class="section" id="s-updating-multiple-objects-at-once">
<span id="s-topics-db-queries-update"></span><span id="updating-multiple-objects-at-once"></span><span id="topics-db-queries-update"></span><h2><font id="367">一次更新多个对象</font><a class="headerlink" href="queries.html#updating-multiple-objects-at-once" title="Permalink to this headline">¶</a></h2>
<p><font id="265">有时你想为一个<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>中所有对象的某个字段都设置一个特定的值。</font><font id="266">这时你可以使用<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt></a> 方法。</font><font id="267">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Update all the headlines with pub_date in 2007.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2007</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'Everything is the same'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="268">你只可以对非关联字段和<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> 字段使用这个方法。</font><font id="269">若要更新一个非关联字段，只需提供一个新的常数值。</font><font id="270">若要更新<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> 字段，需设置新的值为你想指向的新的模型实例。</font><font id="271">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Change every Entry so that it belongs to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="272"><tt class="docutils literal"><span class="pre">update()</span></tt> 方法会立即执行并返回查询匹配的行数（如果有些行已经具有新的值，返回的行数可能和被更新的行数不相等）。</font><font id="273">更新<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 唯一的限制是它只能访问一个数据库表，也就是模型的主表。</font><font id="274">你可以根据关联的字段过滤，但是你只能更新模型主表中的列。</font><font id="275">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Update all the headlines belonging to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'Everything is the same'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="276">要注意<tt class="docutils literal"><span class="pre">update()</span></tt> 方法会直接转换成一个SQL 语句。</font><font id="277">它是一个批量的直接更新操作。</font><font id="278">它不会运行模型的<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 方法，或者发出<tt class="docutils literal"><span class="pre">pre_save</span></tt>&nbsp;或 <tt class="docutils literal"><span class="pre">post_save</span></tt>信号（调用<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>方法产生）或者查看<a class="reference internal" href="../../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><tt class="xref py py-attr docutils literal"><span class="pre">auto_now</span></tt></a>&nbsp;字段选项。</font><font id="279">如果你想保存<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>中的每个条目并确保每个实例的<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 方法都被调用，你不需要使用任何特殊的函数来处理。</font><font id="280">只需要迭代它们并调用<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_queryset</span><span class="p">:</span>
    <span class="n">item</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="281">对update 的调用也可以使用<a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><tt class="xref py py-class docutils literal"><span class="pre">F</span> <span class="pre">表达式</span></tt></a> 来根据模型中的一个字段更新另外一个字段。</font><font id="282">这对于在当前值的基础上加上一个值特别有用。</font><font id="283">例如，增加Blog 中每个Entry 的pingback 个数：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n_pingbacks</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">'n_pingbacks'</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="284">然而，与filter 和exclude 子句中的<tt class="docutils literal"><span class="pre">F()</span></tt> 对象不同，在update 中你不可以使用<tt class="docutils literal"><span class="pre">F()</span></tt> 对象引入join —— 你只可以引用正在更新的模型的字段。</font><font id="285">如果你尝试使用<tt class="docutils literal"><span class="pre">F()</span></tt> 对象引入一个join，将引发一个<tt class="docutils literal"><span class="pre">FieldError</span></tt>：</font></p>
<div class="highlight-python"><div class="highlight"><pre># THIS WILL RAISE A FieldError
&gt;&gt;&gt; Entry.objects.update(headline=F('blog__name'))
</pre></div>
</div>
</div>
<div class="section" id="s-related-objects">
<span id="s-topics-db-queries-related"></span><span id="related-objects"></span><span id="topics-db-queries-related"></span><h2><font id="368">关联的对象</font><a class="headerlink" href="queries.html#related-objects" title="Permalink to this headline">¶</a></h2>
<p><font id="286">当你在一个模型中定义一个管理关系时（例如，<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a>、 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><tt class="xref py py-class docutils literal"><span class="pre">OneToOneField</span></tt></a> 或<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a>），该模型的实例将带有一个方便的API 来访问关联的对象。</font></p>
<p><font id="287">利用本页顶部的模型，一个<tt class="docutils literal"><span class="pre">Entry</span></tt> 对象<tt class="docutils literal"><span class="pre">e</span></tt> 可以通过<tt class="docutils literal"><span class="pre">blog</span></tt> 属性<tt class="docutils literal"><span class="pre">e.blog</span></tt> 获取关联的<tt class="docutils literal"><span class="pre">Blog</span></tt> 对象。</font></p>
<p><font id="288">（在幕后，这个功能是通过Python 的<a class="reference external" href="http://users.rcn.com/python/download/Descriptor.htm">描述器</a>实现的。</font><font id="289">这应该不会对你有什么真正的影响，但是这里我们指出它以满足你的好奇）。</font></p>
<p><font id="290">Django 还会创建API 用于访问关联关系的另一头 —— 从关联的模型访问定义关联关系的模型。</font><font id="291">例如，<tt class="docutils literal"><span class="pre">Blog</span></tt> 对象<tt class="docutils literal"><span class="pre">b</span></tt> 可以通过<tt class="docutils literal"><span class="pre">entry_set</span></tt> 属性 <tt class="docutils literal"><span class="pre">b.entry_set.all()</span></tt>访问与它关联的所有<tt class="docutils literal"><span class="pre">Entry</span></tt> 对象。</font></p>
<p><font id="292">这一节中的所有示例都将使用本页顶部定义的<tt class="docutils literal"><span class="pre">Blog</span></tt>、 <tt class="docutils literal"><span class="pre">Author</span></tt> 和<tt class="docutils literal"><span class="pre">Entry</span></tt> 模型。</font></p>
<div class="section" id="s-one-to-many-relationships">
<span id="one-to-many-relationships"></span><h3><font id="382">一对多关系</font><a class="headerlink" href="queries.html#one-to-many-relationships" title="Permalink to this headline">¶</a></h3>
<div class="section" id="s-forward">
<span id="forward"></span><h4><font id="398">前向查询</font><a class="headerlink" href="queries.html#forward" title="Permalink to this headline">¶</a></h4>
<p><font id="293">如果一个模型具有<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a>，那么该模型的实例将可以通过属性访问关联的（外部）对象。</font></p>
<p><font id="294">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="c"># Returns the related Blog object.</span>
</pre></div>
</div>
<p><font id="295">你可以通过外键属性获取和设置。</font><font id="296">和你预期的一样，对外键的修改不会保存到数据库中直至你调用<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>。</font><font id="297">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">some_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="298">如果<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> 字段有<tt class="docutils literal"><span class="pre">null=True</span></tt> 设置（即它允许<tt class="docutils literal"><span class="pre">NULL</span></tt> 值），你可以分配<tt class="docutils literal"><span class="pre">None</span></tt> 来删除对应的关联性。</font><font id="299">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="c"># "UPDATE blog_entry SET blog_id = NULL ...;"</span>
</pre></div>
</div>
<p><font id="300">一对多关联关系的前向访问在第一次访问关联的对象时被缓存。</font><font id="301">以后对同一个对象的外键的访问都使用缓存。</font><font id="302">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c"># Hits the database to retrieve the associated Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c"># Doesn't hit the database; uses cached version.</span>
</pre></div>
</div>
<p><font id="303">注意<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><tt class="xref py py-meth docutils literal"><span class="pre">select_related()</span></tt></a> <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a>方法递归地预填充所有的一对多关系到缓存中。</font><font id="304">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c"># Doesn't hit the database; uses cached version.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c"># Doesn't hit the database; uses cached version.</span>
</pre></div>
</div>
</div>
<div class="section" id="s-following-relationships-backward">
<span id="s-backwards-related-objects"></span><span id="following-relationships-backward"></span><span id="backwards-related-objects"></span><h4>Following relationships “backward”<a class="headerlink" href="queries.html#following-relationships-backward" title="Permalink to this headline">¶</a></h4>
<p><font id="305">如果模型有一个<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a>，该外键所指的模型实例可以通过一个<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>返回第一个模型的所有实例。</font><font id="306">默认情况下，这个<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a> 名字为<tt class="docutils literal"><span class="pre">FOO_set</span></tt>，其中<tt class="docutils literal"><span class="pre">FOO</span></tt> 是源模型的小写名称。</font><font id="307">该<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a> 返回的<tt class="docutils literal"><span class="pre">QuerySets</span></tt> 可以用上一节提到的方式过滤和操作。</font></p>
<p><font id="308">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entry_set is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="309">你可以通过设置<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> 定义中的<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><tt class="xref py py-attr docutils literal"><span class="pre">related_name</span></tt></a> 参数来覆盖<tt class="docutils literal"><span class="pre">FOO_set</span></tt> 的名称。</font><font id="310">例如，如果<tt class="docutils literal"><span class="pre">Entry</span></tt> 模型被改成<tt class="docutils literal"><span class="pre">blog</span> <span class="pre">=</span> <span class="pre">ForeignKey(Blog,</span> <span class="pre">related_name='entries')</span></tt>，那么上面的示例代码应该改成这样：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entries is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-using-a-custom-reverse-manager">
<span id="s-using-custom-reverse-manager"></span><span id="using-a-custom-reverse-manager"></span><span id="using-custom-reverse-manager"></span><h4><font id="399">使用自定义的反向管理器</font><a class="headerlink" href="queries.html#using-a-custom-reverse-manager" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">New in Django 1.7.</span> </div>
<p><font id="311">默认情况下，用于反向关联关系的<a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager" title="django.db.models.fields.related.RelatedManager"><tt class="xref py py-class docutils literal"><span class="pre">RelatedManager</span></tt></a> 是该模型<a class="reference internal" href="managers.html#manager-names"><em>默认管理器</em></a> 的子类。</font><font id="312">如果你想为一个查询指定一个不同的管理器，你可以使用下面的语法：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c">#...</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>  <span class="c"># Default Manager</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="n">EntryManager</span><span class="p">()</span>    <span class="c"># Custom Manager</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s">'entries'</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="313">如果<tt class="docutils literal"><span class="pre">EntryManager</span></tt> 在它的<tt class="docutils literal"><span class="pre">get_queryset()</span></tt> 方法中使用默认的过滤，那么该过滤将适用于<tt class="docutils literal"><span class="pre">all()</span></tt> 调用。</font></p>
<p><font id="314">当然，指定一个自定义的管理器还可以放你调用自定义的方法：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s">'entries'</span><span class="p">)</span><span class="o">.</span><span class="n">is_published</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-additional-methods-to-handle-related-objects">
<span id="additional-methods-to-handle-related-objects"></span><h4><font id="400">处理关联对象的其它方法</font><a class="headerlink" href="queries.html#additional-methods-to-handle-related-objects" title="Permalink to this headline">¶</a></h4>
<p><font id="315">出了在上面”获取对象“一节中定义的<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><tt class="xref py py-class docutils literal"><span class="pre">查询集</span></tt></a> 方法之外，<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a> 还有其它方法用于处理关联的对象集合。</font><font id="316">下面是每个方法的大概，完整的细节可以在<a class="reference internal" href="../../ref/models/relations.html"><em>关联对象参考</em></a> 中找到。</font></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">add(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></tt></dt>
<dd><font id="448">添加一指定的模型对象到关联的对象集中。</font></dd>
<dt><tt class="docutils literal"><span class="pre">create(**kwargs)</span></tt></dt>
<dd><font id="449">创建一个新的对象，将它保存并放在关联的对象集中。</font><font id="450">返回新创建的对象。</font></dd>
<dt><tt class="docutils literal"><span class="pre">remove(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></tt></dt>
<dd><font id="451">从关联的对象集中删除指定的模型对象。</font></dd>
<dt><tt class="docutils literal"><span class="pre">clear()</span></tt></dt>
<dd><font id="452">从关联的对象集中删除所有的对象。</font></dd>
</dl>
<p><font id="317">若要一次性给关联的对象集赋值，只需要给它赋值一个可迭代的对象。</font><font id="318">这个可迭代的对象可以包含对象的实例，或者一个主键值的列表。</font><font id="319">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">]</span>
</pre></div>
</div>
<p><font id="320">在这个例子中，<tt class="docutils literal"><span class="pre">e1</span></tt> 和<tt class="docutils literal"><span class="pre">e2</span></tt> 可以是Entry 实例，也可以是主键的整数值。</font></p>
<p><font id="321">如果有<tt class="docutils literal"><span class="pre">clear()</span></tt> 方法，那么在将可迭代对象中的成员添加到集合中之前，将从<tt class="docutils literal"><span class="pre">entry_set</span></tt> 中删除所有已经存在的对象。</font><font id="322">如果<em>没有</em><tt class="docutils literal"><span class="pre">clear()</span></tt> 方法，那么将直接添加可迭代对象中的成员而不会删除所有已存在的对象。</font></p>
<p><font id="323">这一节中提到的每个”反向“操作都会立即对数据库产生作用。</font><font id="324">每个添加、创建和删除操作都会立即并自动保存到数据库中。</font></p>
</div>
</div>
<div class="section" id="s-many-to-many-relationships">
<span id="s-m2m-reverse-relationships"></span><span id="many-to-many-relationships"></span><span id="m2m-reverse-relationships"></span><h3><font id="383">多对多关系</font><a class="headerlink" href="queries.html#many-to-many-relationships" title="Permalink to this headline">¶</a></h3>
<p><font id="325">多对多关系的两端都会自动获得访问另一端的API。</font><font id="326">这些API 的工作方式与上面提到的“方向”一对多关系一样。</font></p>
<p><font id="327">唯一的区别在于属性的名称：定义&nbsp;<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a> 的模型使用该字段的属性名称，而“反向”模型使用初识的模型的小写名称加上<tt class="docutils literal"><span class="pre">'_set'</span></tt> （和一对多关系一样）。</font></p>
<p><font id="328">一个例子可以让它更好理解：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Author objects for this Entry.</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">'John'</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Entry objects for this Author.</span>
</pre></div>
</div>
<p><font id="329">类似<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a>，<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a> 可以指定<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.related_name" title="django.db.models.ManyToManyField.related_name"><tt class="xref py py-attr docutils literal"><span class="pre">related_name</span></tt></a>。</font><font id="330">在上面的例子中，如果<tt class="docutils literal"><span class="pre">Entry</span></tt> 中的<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><tt class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></tt></a> 指定<tt class="docutils literal"><span class="pre">related_name='entries'</span></tt>，那么<tt class="docutils literal"><span class="pre">Author</span></tt> 实例将使用 <tt class="docutils literal"><span class="pre">entries</span></tt> 属性而不是<tt class="docutils literal"><span class="pre">entry_set</span></tt>。</font></p>
</div>
<div class="section" id="s-one-to-one-relationships">
<span id="one-to-one-relationships"></span><h3><font id="384">一对一关系</font><a class="headerlink" href="queries.html#one-to-one-relationships" title="Permalink to this headline">¶</a></h3>
<p><font id="331">一对一关系与多对一关系非常相似。</font><font id="332">如果你在模型中定义一个<a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><tt class="xref py py-class docutils literal"><span class="pre">OneToOneField</span></tt></a>，该模型的实例将可以通过该模型的一个简单属性访问关联的模型。</font></p>
<p><font id="333">例如：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">EntryDetail</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span><span class="n">Entry</span><span class="p">)</span>
    <span class="n">details</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

<span class="n">ed</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ed</span><span class="o">.</span><span class="n">entry</span> <span class="c"># Returns the related Entry object.</span>
</pre></div>
</div>
<p><font id="334">在“反向”查询中有所不同。</font><font id="335">一对一关系中的关联模型同样具有一个<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>对象，但是该<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><tt class="xref py py-class docutils literal"><span class="pre">管理器</span></tt></a>表示一个单一的对象而不是对象的集合：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="c"># returns the related EntryDetail object</span>
</pre></div>
</div>
<p><font id="336">如果没有对象赋值给这个关联关系，Django 将引发一个<tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常。</font></p>
<p><font id="337">实例可以赋值给反向的关联关系，方法和正向的关联关系一样：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="o">=</span> <span class="n">ed</span>
</pre></div>
</div>
</div>
<div class="section" id="s-how-are-the-backward-relationships-possible">
<span id="how-are-the-backward-relationships-possible"></span><h3><font id="385">反向的关联关系是如何实现的？</font><a class="headerlink" href="queries.html#how-are-the-backward-relationships-possible" title="Permalink to this headline">¶</a></h3>
<p><font id="338">其它对象关系映射要求你在关联关系的两端都要定义。</font><font id="339">Django 的开发人员相信这是对DRY（不要重复你自己）原则的违背，所以Django 只要求你在一端定义关联关系。</font></p>
<p><font id="340">但是这怎么可能，因为一个模型类不知道哪个模型类与它关联直到其它模型类被加载？</font></p>
<p><font id="341">答案在<a class="reference internal" href="../../ref/applications.html#django.apps.apps" title="django.apps.apps"><tt class="xref py py-data docutils literal"><span class="pre">app</span> <span class="pre">registry</span></tt></a> 中。</font><font id="342">当Django 启动时，它导入<a class="reference internal" href="../../ref/settings.html#std:setting-INSTALLED_APPS"><tt class="xref std std-setting docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> 中列出的每个应用，然后导入每个应用中的<tt class="docutils literal"><span class="pre">models</span></tt> 模块。</font><font id="343">每创建一个新的模型时，Django 添加反向的关系到所有关联的模型。</font><font id="344">如果关联的模型还没有导入，Django 将保存关联关系的记录并在最终关联的模型导入时添加这些关联关系。</font></p>
<p><font id="345">由于这个原因，你使用的所有模型都在<a class="reference internal" href="../../ref/settings.html#std:setting-INSTALLED_APPS"><tt class="xref std std-setting docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> 列出的应用中有定义。</font><font id="346">否则，反向的关联关系将不能正确工作。</font></p>
</div>
<div class="section" id="s-queries-over-related-objects">
<span id="queries-over-related-objects"></span><h3><font id="386">在关联对象上的查询</font><a class="headerlink" href="queries.html#queries-over-related-objects" title="Permalink to this headline">¶</a></h3>
<p><font id="347">关联对象字段的查询与正常字段的查询遵循同样的规则。</font><font id="348">当你指定查询需要匹配的一个值时，你可以使用一个对象实例或者对象的主键的值。</font></p>
<p><font id="349">例如，如果你有一个<tt class="docutils literal"><span class="pre">id=5</span></tt> 的Blog 对象<tt class="docutils literal"><span class="pre">b</span></tt>，下面的三个查询将是完全一样的：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span> <span class="c"># Query using object instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="c"># Query using id from instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="c"># Query using id directly</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-falling-back-to-raw-sql">
<span id="falling-back-to-raw-sql"></span><h2><font id="369">回归到原始的 SQL</font><a class="headerlink" href="queries.html#falling-back-to-raw-sql" title="Permalink to this headline">¶</a></h2>
<p><font id="350">如果你发现需要编写的SQL 查询对于Django 的数据库映射机制太复杂，你可以回归到手工编写SQL。</font><font id="351">Django 对于编写原始的SQL 查询有多个选项；</font><font id="352">参见<a class="reference internal" href="sql.html"><em>执行原始的SQL 查询</em></a>。</font></p>
<p><font id="353">最后，值得注意的是Django 的数据库层只是数据库的一个接口。</font><font id="354">你可以利用其它工具、编程语言或数据库框架来访问数据库；</font><font id="355">对于数据库，Django 没有什么特别的地方。</font></p>
</div>
</div>
</div>
</div>
</div>
<div class="yui-b" id="sidebar">
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<h3><font id="387">目录</font></h3>
<ul>
<li><a class="reference internal" href="queries.html#"><font id="401">执行查询</font></a><ul>
<li><a class="reference internal" href="queries.html#creating-objects"><font id="402">创建对象</font></a></li>
<li><a class="reference internal" href="queries.html#saving-changes-to-objects"><font id="403">保存对象的改动</font></a><ul>
<li><a class="reference internal" href="queries.html#saving-foreignkey-and-manytomanyfield-fields"><font id="404">保存 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 和 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 字段</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="queries.html#retrieving-objects"><font id="405">获取对象</font></a><ul>
<li><a class="reference internal" href="queries.html#retrieving-all-objects"><font id="406">获取所有对象</font></a></li>
<li><a class="reference internal" href="queries.html#retrieving-specific-objects-with-filters"><font id="407">使用过滤器获取特定对象</font></a><ul>
<li><a class="reference internal" href="queries.html#chaining-filters"><font id="408">链式过滤</font></a></li>
<li><a class="reference internal" href="queries.html#filtered-querysets-are-unique"><font id="409">过滤后的结果是独立的</font></a></li>
<li><a class="reference internal" href="queries.html#querysets-are-lazy"><font id="410">查询集是惰性的</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="queries.html#retrieving-a-single-object-with-get"><font id="411">使用get 获取单个对象</font></a></li>
<li><a class="reference internal" href="queries.html#other-queryset-methods"><font id="412">其它查询集方法</font></a></li>
<li><a class="reference internal" href="queries.html#limiting-querysets"><font id="413">限制查询集</font></a></li>
<li><a class="reference internal" href="queries.html#field-lookups"><font id="414">字段查询</font></a></li>
<li><a class="reference internal" href="queries.html#lookups-that-span-relationships"><font id="415">跨关联关系的查询</font></a><ul>
<li><a class="reference internal" href="queries.html#spanning-multi-valued-relationships"><font id="416">跨越多值关联关系</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="queries.html#filters-can-reference-fields-on-the-model"><font id="417">过滤器可以引用模型的字段</font></a></li>
<li><a class="reference internal" href="queries.html#the-pk-lookup-shortcut"><font id="418">查询快捷方式pk</font></a></li>
<li><a class="reference internal" href="queries.html#escaping-percent-signs-and-underscores-in-like-statements"><font id="419">Escaping percent signs and underscores in LIKE statements</font></a></li>
<li><a class="reference internal" href="queries.html#caching-and-querysets"><font id="420">缓存和查询集</font></a><ul>
<li><a class="reference internal" href="queries.html#when-querysets-are-not-cached"><font id="421">查询集何时不缓存</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="queries.html#complex-lookups-with-q-objects"><font id="422">使用Q 对象进行复杂的查询</font></a></li>
<li><a class="reference internal" href="queries.html#comparing-objects"><font id="423">比较对象</font></a></li>
<li><a class="reference internal" href="queries.html#deleting-objects"><font id="424">删除对象</font></a></li>
<li><a class="reference internal" href="queries.html#copying-model-instances"><font id="425">拷贝模型实例</font></a></li>
<li><a class="reference internal" href="queries.html#updating-multiple-objects-at-once"><font id="426">一次更新多个对象</font></a></li>
<li><a class="reference internal" href="queries.html#related-objects"><font id="427">关联的对象</font></a><ul>
<li><a class="reference internal" href="queries.html#one-to-many-relationships"><font id="428">一对多关系</font></a><ul>
<li><a class="reference internal" href="queries.html#forward"><font id="429">Forward</font></a></li>
<li><a class="reference internal" href="queries.html#following-relationships-backward">Following relationships “backward”</a></li>
<li><a class="reference internal" href="queries.html#using-a-custom-reverse-manager"><font id="430">Using a custom reverse manager</font></a></li>
<li><a class="reference internal" href="queries.html#additional-methods-to-handle-related-objects"><font id="431">Additional methods to handle related objects</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="queries.html#many-to-many-relationships"><font id="432">多对多关系</font></a></li>
<li><a class="reference internal" href="queries.html#one-to-one-relationships"><font id="433">一对一关系</font></a></li>
<li><a class="reference internal" href="queries.html#how-are-the-backward-relationships-possible"><font id="434">How are the backward relationships possible?</font></a></li>
<li><a class="reference internal" href="queries.html#queries-over-related-objects"><font id="435">Queries over related objects</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="queries.html#falling-back-to-raw-sql"><font id="436">回归到原始的 SQL</font></a></li>
</ul>
</li>
</ul>
<h3><font id="388">Browse</font></h3>
<ul>
<li><font id="437">Prev: <a href="models.html">Models</a></font></li>
<li><font id="438">Next: <a href="aggregation.html">Aggregation</a></font></li>
</ul>
<h3><font id="389">你在这里：</font></h3>
<ul>
<li>
<a href="../../index.html"><font id="439">Django 1.8.2 文档</font></a>
<ul><li><a href="../index.html"><font id="440">Using Django</font></a>
<ul><li><a href="index.html"><font id="441">模型和数据库</font></a>
<ul><li><font id="442">Making queries</font></li></ul>
</li></ul></li></ul>
</li>
</ul>
<h3><font id="390">This Page</font></h3>
<ul class="this-page-menu">
<li><a href="http://python.usyiyi.cn/django/_sources/topics/db/queries.txt" rel="nofollow"><font id="443">Show Source</font></a></li>
</ul>
<div id="searchbox" style="display: none">
<h3><font id="391">Quick search</font></h3>
<form action="http://python.usyiyi.cn/django/search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<p class="searchtip" style="font-size: 90%"><font id="356"> Enter search terms or a module, class or function name. </font></p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<h3><font id="392">最后更新：</font></h3>
<p class="topless"><font id="357">May 13, 2015</font></p>
</div>
</div>
<div id="ft">
<div class="nav">
    « <a href="models.html" title="Models">previous</a>
     |
    <a accesskey="U" href="../index.html" title="Using Django">up</a>
   |
    <a href="aggregation.html" title="Aggregation">next</a> »</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div id="disqus_thread"></div><br>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'djangocn'; // required: replace example with your forum shortname
    var disqus_identifier = '/django/topics/db/queries';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<link href="http://python.usyiyi.cn/django/_static/ms_translator.css" rel="stylesheet" type="text/css"/>
<script src="http://python.usyiyi.cn/django/_static/ms_translator.js" type="text/javascript"></script>
<script src="http://python.usyiyi.cn/django/_static/jquery-ui-1.9.2.custom.min.js" type="text/javascript"></script>
<div id="MicrosoftTranslator" style="display:none; position: absolute; z-index: 2147483647; margin: 0px; border: 2px solid rgb(210, 210, 210); padding: 0px; color: rgb(0, 0, 0); background-color: rgb(230, 230, 230); font-family: Arial,Helvetica,Sans-Serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 12px; line-height: normal; direction: ltr; text-align: left; left: 274px; top: 2048.03px; min-width: 400px;">
    <div id="MSTCClose" style="float: right;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/tooltip_close.gif">
      </a>
    </div>
    
    <div id="MSTCPopDown" style="float: right;" style="display: none;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/popdown.gif">
      </a>
    </div>
    <div id="MSTCPopUP" style="float: right;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/popup.gif">
      </a>
    </div>
    
    <div id="MSTCTitle" style="margin: 4px 4px 8px; font-weight: bold;">原文
    </div>
    
    <div style="direction: ltr; text-align: left;">
      <span id="MSTCOrigion" style="display: inline-block; margin: 0px 4px 4px;"> </span>
    </div>
    
    <div id="MicrosoftTranslatorCommunity" class="MSTCltr">
      <div id="MSTCContent">
        <a id="MSTCExpandLink">
          <span id="MSTCImprove">改进翻译</span>
          <span id="MSTCSuggest">最小化</span>
          <img src="http://python.usyiyi.cn/django/_static/ctftoggledown.gif" id="MSTCToggleDown">
          <img src="http://python.usyiyi.cn/django/_static/ctftoggleup.gif" id="MSTCToggleUp">
        </a>
        <div id="MSTCRootPanel">
          <span id="MSTCLoading" style="display: none;">正在加载...</span>
          <div style="display: none;" id="MSTCTransPanelError">
            <div class="MSTCTableRow">
              <div class="MSTCTransPanelExc MSTCTableCell">
                <img style="border-width:0px;" src="http://python.usyiyi.cn/django/_static/error_exclamation.gif" id="ExclamationImage">
              </div>
              <div class="MSTCTableCell">
                <span id="MSTCTransPanelErrorMsg"></span>
              </div>
            </div>
            <div class="MSTCTableRow">
              <div class="MSTCTableCell"></div>
              <div class="MSTCTableCell MSTCFlipHoriz">
                <input type="image" style="border-width:0px;" src="http://python.usyiyi.cn/django/_static/error_OK.gif" class="MSTCErrorButtons" id="MSTCOKImgBtn" name="MSTCOKImgBtn">
              </div>
            </div>
          </div>
          
          <div id="MSTCTransPanel">
          </div>
          
          <div id="MSTCPrevNextPanel">
            <a id="MSTCPrevLink" style='border-right-width: 1px;border-right-style: solid;padding-right: 5px;'>
              <span>上一页</span>
            </a>
            <a style='color: black; border-right-width: 1px;border-right-style: solid;padding-right: 5px;'>
              <span>第</span>
              <span id="MSTCPage"></span>
              <span>页</span>
            </a>
            <a id="MSTCNextLink" style='padding-left: 5px;'>
              <span>下一页</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

</body>
</html>