<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>聚合 — Django 1.8.2 中文文档</title>
<link href="../../_static/default.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.8.2.dev20150513143415',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<link href="../../index.html" rel="top" title="Django 1.8.2.dev20150513143415 documentation"/>
<link href="index.html" rel="up" title="Models and databases"/>
<link href="managers.html" rel="next" title="Managers"/>
<link href="queries.html" rel="prev" title="Making queries"/>
<script src="http://python.usyiyi.cn/django/templatebuiltins.js" type="text/javascript"></script>
<script type="text/javascript">
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='http://python.usyiyi.cn/django/topics/db/&quot;&#32;+&#32;base&#32;+&#32;&quot;#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='http://python.usyiyi.cn/django/topics/db/&quot;&#32;+&#32;base&#32;+&#32;&quot;#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);
</script>
</head>
<body>
<div class="document">
<div class="yui-t6" id="custom-doc">
<div id="hd">
<h1><font id="131">Django 1.8.2 文档</font></h1>
<div id="global-nav">
<a href="../../index.html" title="Home page">Home</a>  |
        <a href="../../contents.html" title="Table of contents">Table of contents</a>  |
        <a href="../../genindex.html" title="Global index">Index</a>  |
        <a href="../../py-modindex.html" title="Module index">Modules</a>
</div>
<div class="nav">
    « <a href="queries.html" title="Making queries">previous</a>
     |
    <a accesskey="U" href="../index.html" title="Using Django">up</a>
   |
    <a href="managers.html" title="Managers">next</a> »</div>
</div>
<div id="bd">
<div id="yui-main">
<div class="yui-b">
<div class="yui-g" id="topics-db-aggregation">
<div class="section" id="s-aggregation">
<span id="aggregation"></span><h1><font id="132">聚合</font><a class="headerlink" href="aggregation.html#aggregation" title="Permalink to this headline">¶</a></h1>
<p><font id="1"><a class="reference internal" href="queries.html"><em>Django数据库抽象API</em></a>描述了使用Django查询来增删查改单个对象的方法。</font><font id="2">然而，你有时候会想要获取从一组对象导出的值或者是<em>聚合</em>一组对象。</font><font id="3">这份指南描述了通过Django查询来生成和返回聚合值的方法。</font></p>
<p><font id="4">整篇指南我们都将引用以下模型。</font><font id="5">这些模型用来记录多个网上书店的库存。</font></p>
<div class="highlight-python" id="queryset-model-example"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Publisher</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="n">num_awards</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="n">pages</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DecimalField</span><span class="p">(</span><span class="n">max_digits</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">decimal_places</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">rating</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">FloatField</span><span class="p">()</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
    <span class="n">publisher</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Publisher</span><span class="p">)</span>
    <span class="n">pubdate</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Store</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="n">books</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Book</span><span class="p">)</span>
    <span class="n">registered_users</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">PositiveIntegerField</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="s-cheat-sheet">
<span id="cheat-sheet"></span><h2><font id="133">速查表</font><a class="headerlink" href="aggregation.html#cheat-sheet" title="Permalink to this headline">¶</a></h2>
<p><font id="6">急着用吗？</font><font id="7">以下是在上述模型的基础上，进行一般的聚合查询的方法:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Total number of books.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="mi">2452</span>

<span class="c"># Total number of books with publisher=BaloneyPress</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">publisher__name</span><span class="o">=</span><span class="s">'BaloneyPress'</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="mi">73</span>

<span class="c"># Average price across all books.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Avg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Avg</span><span class="p">(</span><span class="s">'price'</span><span class="p">))</span>
<span class="p">{</span><span class="s">'price__avg'</span><span class="p">:</span> <span class="mf">34.35</span><span class="p">}</span>

<span class="c"># Max price across all books.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Max</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Max</span><span class="p">(</span><span class="s">'price'</span><span class="p">))</span>
<span class="p">{</span><span class="s">'price__max'</span><span class="p">:</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">'81.20'</span><span class="p">)}</span>

<span class="c"># Cost per page</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
<span class="o">...</span>    <span class="n">price_per_page</span><span class="o">=</span><span class="n">Sum</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="s">'price'</span><span class="p">)</span><span class="o">/</span><span class="n">F</span><span class="p">(</span><span class="s">'pages'</span><span class="p">),</span> <span class="n">output_field</span><span class="o">=</span><span class="n">FloatField</span><span class="p">()))</span>
<span class="p">{</span><span class="s">'price_per_page'</span><span class="p">:</span> <span class="mf">0.4470664529184653</span><span class="p">}</span>

<span class="c"># All the following queries involve traversing the Book&lt;-&gt;Publisher</span>
<span class="c"># many-to-many relationship backward</span>

<span class="c"># Each publisher, each with a count of books as a "num_books" attribute.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pubs</span> <span class="o">=</span> <span class="n">Publisher</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_books</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'book'</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pubs</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">Publisher</span> <span class="n">BaloneyPress</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Publisher</span> <span class="n">SalamiPress</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pubs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_books</span>
<span class="mi">73</span>

<span class="c"># The top 5 publishers, in order by number of books.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pubs</span> <span class="o">=</span> <span class="n">Publisher</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_books</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'book'</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'-num_books'</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pubs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_books</span>
<span class="mi">1323</span>
</pre></div>
</div>
</div>
<div class="section" id="s-generating-aggregates-over-a-queryset">
<span id="generating-aggregates-over-a-queryset"></span><h2><font id="134">在查询集上生成聚合</font><a class="headerlink" href="aggregation.html#generating-aggregates-over-a-queryset" title="Permalink to this headline">¶</a></h2>
<p><font id="8">Django提供了两种生成聚合的方法。</font><font id="9">第一种方法是从整个<tt class="docutils literal"><span class="pre">查询集</span></tt>生成统计值。</font><font id="10">比如，你想要计算所有在售书的平均价钱。</font><font id="11">Django的查询语法提供了一种方式描述所有图书的集合。</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="12">我们需要在<tt class="docutils literal"><span class="pre">QuerySet</span></tt>.对象上计算出总价格。</font><font id="13">这可以通过在<tt class="docutils literal"><span class="pre">QuerySet</span></tt>后面附加<tt class="docutils literal"><span class="pre">aggregate()</span></tt> 子句来完成。</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Avg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Avg</span><span class="p">(</span><span class="s">'price'</span><span class="p">))</span>
<span class="go">{'price__avg': 34.35}</span>
</pre></div>
</div>
<p><font id="14"><tt class="docutils literal"><span class="pre">all()</span></tt>在这里是多余的，所以可以简化为：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Avg</span><span class="p">(</span><span class="s">'price'</span><span class="p">))</span>
<span class="go">{'price__avg': 34.35}</span>
</pre></div>
</div>
<p><font id="15"><tt class="docutils literal"><span class="pre">aggregate()</span></tt>子句的参数描述了我们想要计算的聚合值，在这个例子中，是<tt class="docutils literal"><span class="pre">Book</span></tt> 模型中<tt class="docutils literal"><span class="pre">price</span></tt>字段的平均值。</font><font id="16"><a class="reference internal" href="../../ref/models/querysets.html#aggregation-functions"><em>查询集参考</em></a>中列出了聚合函数的列表。</font></p>
<p><font id="17"><tt class="docutils literal"><span class="pre">aggregate()</span></tt>是<tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。</font><font id="18">键的名称是聚合值的标识符，</font><font id="19">值是计算出来的聚合值。</font><font id="20">键的名称是按照字段和聚合函数的名称自动生成出来的。</font><font id="21">如果你想要为聚合值指定一个名称，可以向聚合子句提供它。</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">average_price</span><span class="o">=</span><span class="n">Avg</span><span class="p">(</span><span class="s">'price'</span><span class="p">))</span>
<span class="go">{'average_price': 34.35}</span>
</pre></div>
</div>
<p><font id="22">如果你希望生成不止一个聚合，你可以向<tt class="docutils literal"><span class="pre">aggregate()</span></tt>子句中添加另一个参数。</font><font id="23">所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Avg</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Min</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Avg</span><span class="p">(</span><span class="s">'price'</span><span class="p">),</span> <span class="n">Max</span><span class="p">(</span><span class="s">'price'</span><span class="p">),</span> <span class="n">Min</span><span class="p">(</span><span class="s">'price'</span><span class="p">))</span>
<span class="go">{'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}</span>
</pre></div>
</div>
</div>
<div class="section" id="s-generating-aggregates-for-each-item-in-a-queryset">
<span id="generating-aggregates-for-each-item-in-a-queryset"></span><h2><font id="135">为查询集的每一项生成聚合</font><a class="headerlink" href="aggregation.html#generating-aggregates-for-each-item-in-a-queryset" title="Permalink to this headline">¶</a></h2>
<p><font id="24">生成汇总值的第二种方法，是为<tt class="docutils literal"><span class="pre">QuerySet</span></tt>中每一个对象都生成一个独立的汇总值。</font><font id="25">比如，如果你在检索一列图书，你可能想知道每一本书有多少作者参与。</font><font id="26">每本书和作者是多对多的关系。</font><font id="27">我们想要汇总<tt class="docutils literal"><span class="pre">QuerySet</span></tt>.中每本书里的这种关系。</font></p>
<p><font id="28">逐个对象的汇总结果可以由<tt class="docutils literal"><span class="pre">annotate()</span></tt>子句生成。</font><font id="29">当<tt class="docutils literal"><span class="pre">annotate()</span></tt>子句被指定之后，<tt class="docutils literal"><span class="pre">QuerySet</span></tt>中的每个对象都会被注上特定的值。</font></p>
<p><font id="30">这些注解的语法都和<tt class="docutils literal"><span class="pre">aggregate()</span></tt>子句所使用的相同。</font><font id="31"><tt class="docutils literal"><span class="pre">annotate()</span></tt>的每个参数都描述了将要被计算的聚合。</font><font id="32">比如，给图书添加作者数量的注解：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Build an annotated queryset</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">'authors'</span><span class="p">))</span>
<span class="c"># Interrogate the first object in the queryset</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&lt;</span><span class="n">Book</span><span class="p">:</span> <span class="n">The</span> <span class="n">Definitive</span> <span class="n">Guide</span> <span class="n">to</span> <span class="n">Django</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">authors__count</span>
<span class="mi">2</span>
<span class="c"># Interrogate the second object in the queryset</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&lt;</span><span class="n">Book</span><span class="p">:</span> <span class="n">Practical</span> <span class="n">Django</span> <span class="n">Projects</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">authors__count</span>
<span class="mi">1</span>
</pre></div>
</div>
<p><font id="33">和使用 <tt class="docutils literal"><span class="pre">aggregate()</span></tt>一样，注解的名称也根据聚合函式的名称和聚合字段的名称得到的。</font><font id="34">你可以在指定注解时，为默认名称提供一个别名：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_authors</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'authors'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_authors</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">num_authors</span>
<span class="go">1</span>
</pre></div>
</div>
<p><font id="35">与 <tt class="docutils literal"><span class="pre">aggregate()</span></tt> 不同的是，&nbsp;<tt class="docutils literal"><span class="pre">annotate()</span></tt>&nbsp;<em>不是</em>一个终止子句。</font><font id="36"><tt class="docutils literal"><span class="pre">annotate()</span></tt>子句的返回结果是一个查询集 (<tt class="docutils literal"><span class="pre">QuerySet</span></tt>)；</font><font id="37">这个&nbsp;<tt class="docutils literal"><span class="pre">QuerySet</span></tt>可以用任何<tt class="docutils literal"><span class="pre">QuerySet</span></tt>方法进行修改，包括&nbsp;<tt class="docutils literal"><span class="pre">filter()</span></tt>, <tt class="docutils literal"><span class="pre">order_by()</span></tt>, 甚至是再次应用<tt class="docutils literal"><span class="pre">annotate()</span></tt>。</font></p>
<div class="admonition-if-in-doubt-inspect-the-sql-query admonition">
<p class="first admonition-title"><font id="38">有任何疑问的话，请检查 SQL query！</font></p>
<p><font id="39">要想弄清楚你的查询到底发生了什么，可以考虑检查你<tt class="docutils literal"><span class="pre">QuerySet</span></tt>的&nbsp;<tt class="docutils literal"><span class="pre">query</span></tt> 属性。</font></p>
<p class="last"><font id="40">例如，在<tt class="docutils literal"><span class="pre">annotate()</span></tt>&nbsp;中混入多个聚合将会得出错误的结果，因为<a class="reference external" href="https://code.djangoproject.com/ticket/10060">多个表上做了交叉连接</a>，导致了多余的行聚合。</font></p>
</div>
</div>
<div class="section" id="s-joins-and-aggregates">
<span id="joins-and-aggregates"></span><h2><font id="136">连接和聚合</font><a class="headerlink" href="aggregation.html#joins-and-aggregates" title="Permalink to this headline">¶</a></h2>
<p><font id="41">至此，我们已经了解了作用于单种模型实例的聚合操作， </font><font id="42">但是有时，你也想对所查询对象的关联对象进行聚合。</font></p>
<p><font id="43">在聚合函式中指定聚合字段时，Django 允许你使用同样的&nbsp;<a class="reference internal" href="queries.html#field-lookups-intro"><em>双下划线</em></a>&nbsp;表示关联关系，</font><font id="44">然后 Django 在就会处理要读取的关联表，并得到关联对象的聚合。</font></p>
<p><font id="45">例如，要得到每个书店的价格区别，可以使用如下注解：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Min</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Store</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">min_price</span><span class="o">=</span><span class="n">Min</span><span class="p">(</span><span class="s">'books__price'</span><span class="p">),</span> <span class="n">max_price</span><span class="o">=</span><span class="n">Max</span><span class="p">(</span><span class="s">'books__price'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="46">这段代码告诉 Django 获取<tt class="docutils literal"><span class="pre">书店</span></tt>模型，并连接(通过多对多关系)<tt class="docutils literal"><span class="pre">图书</span></tt>模型，然后对每本书的价格进行聚合，得出最小值和最大值。</font></p>
<p><font id="47">同样的规则也用于 &nbsp;<tt class="docutils literal"><span class="pre">aggregate()</span></tt>&nbsp;子句。</font><font id="48">如果你想知道所有书店中最便宜的书和最贵的书价格分别是多少：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Store</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">min_price</span><span class="o">=</span><span class="n">Min</span><span class="p">(</span><span class="s">'books__price'</span><span class="p">),</span> <span class="n">max_price</span><span class="o">=</span><span class="n">Max</span><span class="p">(</span><span class="s">'books__price'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="49">关系链可以按你的要求一直延伸。 </font><font id="50">例如，想得到所有作者当中最小的年龄是多少，就可以这样写：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Store</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">youngest_age</span><span class="o">=</span><span class="n">Min</span><span class="p">(</span><span class="s">'books__authors__age'</span><span class="p">))</span>
</pre></div>
</div>
<div class="section" id="s-following-relationships-backwards">
<span id="following-relationships-backwards"></span><h3><font id="138">遵循反向关系</font><a class="headerlink" href="aggregation.html#following-relationships-backwards" title="Permalink to this headline">¶</a></h3>
<p><font id="51">和&nbsp;<a class="reference internal" href="queries.html#lookups-that-span-relationships"><em>跨关系查找</em></a>的方法类似，作用在你所查询的模型的关联模型或者字段上的聚合和注解可以遍历"反转"关系。</font><font id="52">关联模型的小写名称和双下划线也用在这里。</font></p>
<p><font id="53">例如，我们可以查询所有出版商，并注上它们一共出了多少本书（注意我们如何用&nbsp;<tt class="docutils literal"><span class="pre">'book'</span></tt>指定<tt class="docutils literal"><span class="pre">Publisher</span></tt> -&gt; <tt class="docutils literal"><span class="pre">Book</span></tt> 的外键反转关系）：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">Avg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Publisher</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">'book'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="54"><tt class="docutils literal"><span class="pre">QuerySet</span></tt>结果中的每一个<tt class="docutils literal"><span class="pre">Publisher</span></tt>都会包含一个额外的属性叫做<tt class="docutils literal"><span class="pre">book__count</span></tt>。</font></p>
<p><font id="55">我们也可以按照每个出版商，查询所有图书中最旧的那本：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Publisher</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">oldest_pubdate</span><span class="o">=</span><span class="n">Min</span><span class="p">(</span><span class="s">'book__pubdate'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="56">（返回的字典会包含一个键叫做 <tt class="docutils literal"><span class="pre">'oldest_pubdate'</span></tt>。</font><font id="57">如果没有指定这样的别名，它会更长一些，像 <tt class="docutils literal"><span class="pre">'book__pubdate__min'</span></tt>。）</font></p>
<p><font id="58">这不仅仅可以应用挂在外键上面。</font><font id="59">还可以用到多对多关系上。</font><font id="60">例如，我们可以查询每个作者，注上它写的所有书（以及合著的书）一共有多少页（注意我们如何使用&nbsp;<tt class="docutils literal"><span class="pre">'book'</span></tt>来指定<tt class="docutils literal"><span class="pre">Author</span></tt> -&gt; <tt class="docutils literal"><span class="pre">Book</span></tt>的多对多的反转关系）：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">total_pages</span><span class="o">=</span><span class="n">Sum</span><span class="p">(</span><span class="s">'book__pages'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="61">（每个返回的<tt class="docutils literal"><span class="pre">QuerySet</span></tt>中的<tt class="docutils literal"><span class="pre">Author</span></tt> 都有一个额外的属性叫做<tt class="docutils literal"><span class="pre">total_pages</span></tt>。</font><font id="62">如果没有指定这样的别名，它会更长一些，像 <tt class="docutils literal"><span class="pre">book__pages__sum</span></tt>。）</font></p>
<p><font id="63">或者查询所有图书的平均评分，这些图书由我们存档过的作者所写：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">average_rating</span><span class="o">=</span><span class="n">Avg</span><span class="p">(</span><span class="s">'book__rating'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="64">（返回的字典会包含一个键叫做<tt class="docutils literal"><span class="pre">'average__rating'</span></tt>。</font><font id="65">如果没有指定这样的别名，它会更长一些，像<tt class="docutils literal"><span class="pre">'book__rating__avg'</span></tt>。）</font></p>
</div>
</div>
<div class="section" id="s-aggregations-and-other-queryset-clauses">
<span id="aggregations-and-other-queryset-clauses"></span><h2><font id="137">聚合和其他查询集子句</font><a class="headerlink" href="aggregation.html#aggregations-and-other-queryset-clauses" title="Permalink to this headline">¶</a></h2>
<div class="section" id="s-filter-and-exclude">
<span id="filter-and-exclude"></span><h3><font id="139"><tt class="docutils literal"><span class="pre">filter()</span></tt> and <tt class="docutils literal"><span class="pre">exclude()</span></tt></font><a class="headerlink" href="aggregation.html#filter-and-exclude" title="Permalink to this headline">¶</a></h3>
<p><font id="66">聚合也可以在过滤器中使用。 </font><font id="67">作用于普通模型字段的任何 <tt class="docutils literal"><span class="pre">filter()</span></tt>(或 <tt class="docutils literal"><span class="pre">exclude()</span></tt>) 都会对聚合涉及的对象进行限制。</font></p>
<p><font id="68">使用<tt class="docutils literal"><span class="pre">annotate()</span></tt> 子句时，过滤器有限制注解对象的作用。</font><font id="69">例如，你想得到以 "Django" 为书名开头的图书作者的总数：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span><span class="p">,</span> <span class="n">Avg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s">"Django"</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_authors</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'authors'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="70">使用<tt class="docutils literal"><span class="pre">aggregate()</span></tt>子句时，过滤器有限制聚合对象的作用。</font><font id="71">例如，你可以算出所有以 "Django" 为书名开头的图书平均价格：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s">"Django"</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Avg</span><span class="p">(</span><span class="s">'price'</span><span class="p">))</span>
</pre></div>
</div>
<div class="section" id="s-filtering-on-annotations">
<span id="filtering-on-annotations"></span><h4><font id="149">对注解过滤</font><a class="headerlink" href="aggregation.html#filtering-on-annotations" title="Permalink to this headline">¶</a></h4>
<p><font id="72">注解值也可以被过滤。 </font><font id="73">像使用其他模型字段一样，注解也可以在<tt class="docutils literal"><span class="pre">filter()</span></tt>和<tt class="docutils literal"><span class="pre">exclude()</span></tt> 子句中使用别名。</font></p>
<p><font id="74">例如，要得到不止一个作者的图书，可以用：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_authors</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'authors'</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">num_authors__gt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="75">这个查询首先生成一个注解结果，然后再生成一个作用于注解上的过滤器。</font></p>
</div>
<div class="section" id="s-order-of-annotate-and-filter-clauses">
<span id="order-of-annotate-and-filter-clauses"></span><h4><font id="150"><tt class="docutils literal"><span class="pre">annotate()</span></tt> 和<tt class="docutils literal"><span class="pre">filter()</span></tt> 子句的顺序</font><a class="headerlink" href="aggregation.html#order-of-annotate-and-filter-clauses" title="Permalink to this headline">¶</a></h4>
<p><font id="76">编写一个包含 <tt class="docutils literal"><span class="pre">annotate()</span></tt> 和 <tt class="docutils literal"><span class="pre">filter()</span></tt>&nbsp; 子句的复杂查询时，要特别注意作用于 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>的子句的顺序。</font></p>
<p><font id="77">当一个<tt class="docutils literal"><span class="pre">annotate()</span></tt> 子句作用于某个查询时，要根据查询的状态才能得出注解值，而状态由 annotate() 位置所决定。</font><font id="78">以这就导致<tt class="docutils literal"><span class="pre">filter()</span></tt> 和 <tt class="docutils literal"><span class="pre">annotate()</span></tt> 不能交换顺序，下面两个查询就是不同的：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Publisher</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_books</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'book'</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">book__rating__gt</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="79">另一个查询：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Publisher</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">book__rating__gt</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_books</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'book'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="80">两个查询都返回了至少出版了一本好书(评分大于 3 分)的出版商。 </font><font id="81">但是第一个查询的注解包含其该出版商发行的所有图书的总数；</font><font id="82">而第二个查询的注解只包含出版过好书的出版商的所发行的图书总数。 </font><font id="83">在第一个查询中，注解在过滤器之前，所以过滤器对注解没有影响。 </font><font id="84">在第二个查询中，过滤器在注解之前，所以，在计算注解值时，过滤器就限制了参与运算的对象的范围。</font></p>
</div>
</div>
<div class="section" id="s-order-by">
<span id="order-by"></span><h3><font id="140">order_by()</font><a class="headerlink" href="aggregation.html#order-by" title="Permalink to this headline">¶</a></h3>
<p><font id="85">注解可以用来做为排序项。 </font><font id="86">在你定义 <tt class="docutils literal"><span class="pre">order_by()</span></tt> 子句时，你提供的聚合可以引用定义的任何别名做为查询中 <tt class="docutils literal"><span class="pre">annotate()</span></tt>子句的一部分。</font></p>
<p><font id="87">例如，根据一本图书作者数量的多少对查询集 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>进行排序：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_authors</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'authors'</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'num_authors'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-values">
<span id="values"></span><h3><font id="141">values()</font><a class="headerlink" href="aggregation.html#values" title="Permalink to this headline">¶</a></h3>
<p><font id="88">通常，注解会添加到每个对象上 —— 一个被注解的<tt class="docutils literal"><span class="pre">QuerySet</span></tt>会为初始<tt class="docutils literal"><span class="pre">QuerySet</span></tt>的每个对象返回一个结果集。</font><font id="89">但是，如果使用了<tt class="docutils literal"><span class="pre">values()</span></tt>子句，它就会限制结果中列的范围，对注解赋值的方法就会完全不同。</font><font id="90">不是在原始的 &nbsp;<tt class="docutils literal"><span class="pre">QuerySet</span></tt>返回结果中对每个对象中添加注解，而是根据定义在<tt class="docutils literal"><span class="pre">values()</span></tt>&nbsp; 子句中的字段组合对先结果进行唯一的分组，</font><font id="91">再根据每个分组算出注解值， </font><font id="92">这个注解值是根据分组中所有的成员计算而得的：</font></p>
<p><font id="93">例如，考虑一个关于作者的查询，查询出每个作者所写的书的平均评分：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">average_rating</span><span class="o">=</span><span class="n">Avg</span><span class="p">(</span><span class="s">'book__rating'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="94">这段代码返回的是数据库中所有的作者以及他们所著图书的平均评分。</font></p>
<p><font id="95">但是如果你使用了<tt class="docutils literal"><span class="pre">values()</span></tt>子句，结果是完全不同的：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">average_rating</span><span class="o">=</span><span class="n">Avg</span><span class="p">(</span><span class="s">'book__rating'</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="96">在这个例子中，作者会按名称分组，所以你只能得到某个<em>唯一</em>的作者分组的注解值。 </font><font id="97">这意味着如果你有两个作者同名，那么他们原本各自的查询结果将被合并到同一个结果中；</font><font id="98">两个作者的所有评分都将被计算为一个平均分。</font></p>
<div class="section" id="s-order-of-annotate-and-values-clauses">
<span id="order-of-annotate-and-values-clauses"></span><h4><font id="151">Order of <tt class="docutils literal"><span class="pre">annotate()</span></tt> and <tt class="docutils literal"><span class="pre">values()</span></tt> clauses</font><a class="headerlink" href="aggregation.html#order-of-annotate-and-values-clauses" title="Permalink to this headline">¶</a></h4>
<p><font id="99">和使用 <tt class="docutils literal"><span class="pre">filter()</span></tt> 子句一样，作用于某个查询的<tt class="docutils literal"><span class="pre">annotate()</span></tt> 和 &nbsp;<tt class="docutils literal"><span class="pre">values()</span></tt> 子句的使用顺序是非常重要的。</font><font id="100">如果<tt class="docutils literal"><span class="pre">values()</span></tt> 子句在 &nbsp;<tt class="docutils literal"><span class="pre">annotate()</span></tt> 之前，就会根据 <tt class="docutils literal"><span class="pre">values()</span></tt> &nbsp;子句产生的分组来计算注解。</font></p>
<p><font id="101">但是，如果 &nbsp;<tt class="docutils literal"><span class="pre">annotate()</span></tt>&nbsp; 子句在 <tt class="docutils literal"><span class="pre">values()</span></tt>子句之前，就会根据整个查询集生成注解。</font><font id="102">在这种情况下，<tt class="docutils literal"><span class="pre">values()</span></tt> 子句只能限制输出的字段范围。</font></p>
<p><font id="103">举个例子，如果我们互换了上个例子中 <tt class="docutils literal"><span class="pre">values()</span></tt>和&nbsp;<tt class="docutils literal"><span class="pre">annotate()</span></tt> 子句的顺序：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">average_rating</span><span class="o">=</span><span class="n">Avg</span><span class="p">(</span><span class="s">'book__rating'</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'average_rating'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="104">这段代码将给每个作者添加一个唯一的字段，</font><font id="105">但只有作者名称和<tt class="docutils literal"><span class="pre">average_rating</span></tt> 注解会返回在输出结果中。</font></p>
<p><font id="106">你也应该注意到 <tt class="docutils literal"><span class="pre">average_rating</span></tt> 显式地包含在返回的列表当中。</font><font id="107">之所以这么做的原因正是因为<tt class="docutils literal"><span class="pre">values()</span></tt>&nbsp; 和 <tt class="docutils literal"><span class="pre">annotate()</span></tt> 子句。</font></p>
<p><font id="108">如果 <tt class="docutils literal"><span class="pre">values()</span></tt> &nbsp;子句在 <tt class="docutils literal"><span class="pre">annotate()</span></tt> 子句之前，注解会被自动添加到结果集中；</font><font id="109">但是，如果 <tt class="docutils literal"><span class="pre">values()</span></tt> 子句作用于<tt class="docutils literal"><span class="pre">annotate()</span></tt> 子句之后，你需要显式地包含聚合列。</font></p>
</div>
<div class="section" id="s-interaction-with-default-ordering-or-order-by">
<span id="interaction-with-default-ordering-or-order-by"></span><h4><font id="152">与默认排序交换或<tt class="docutils literal"><span class="pre">order_by()</span></tt></font><a class="headerlink" href="aggregation.html#interaction-with-default-ordering-or-order-by" title="Permalink to this headline">¶</a></h4>
<p><font id="110">在查询集中的<tt class="docutils literal"><span class="pre">order_by()</span></tt> 部分(或是在模型中默认定义的排序项) 会在选择输出数据时被用到，即使这些字段没有在<tt class="docutils literal"><span class="pre">values()</span></tt> 调用中被指定。</font><font id="111">这些额外的字段可以将相似的数据行分在一起，也可以让相同的数据行相分离。</font><font id="112">在做计数时，就会表现地格外明显：</font></p>
<p><font id="113">通过例子中的方法，假设有一个这样的模型：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s">"name"</span><span class="p">]</span>
</pre></div>
</div>
<p><font id="114">关键的部分就是在模型默认排序项中设置的<tt class="docutils literal"><span class="pre">name</span></tt>字段。</font><font id="115">如果你想知道每个非重复的<tt class="docutils literal"><span class="pre">data</span></tt>值出现的次数，可以这样写：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Warning: not quite correct!</span>
<span class="n">Item</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">"id"</span><span class="p">))</span>
</pre></div>
</div>
<p><font id="116">...这部分代码想通过使用它们公共的 <tt class="docutils literal"><span class="pre">data</span></tt>&nbsp;值来分组 <tt class="docutils literal"><span class="pre">Item</span></tt>对象，然后在每个分组中得到 &nbsp;<tt class="docutils literal"><span class="pre">id</span></tt>&nbsp;值的总数。</font><font id="117">但是上面那样做是行不通的。</font><font id="118">这是因为默认排序项中的 <tt class="docutils literal"><span class="pre">name</span></tt>也是一个分组项，所以这个查询会根据非重复的 <tt class="docutils literal"><span class="pre">(data,</span> <span class="pre">name)</span></tt> 进行分组，而这并不是你本来想要的结果。</font><font id="119">所以，你应该这样改写：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Item</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">"id"</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">()</span>
</pre></div>
</div>
<p><font id="120">...这样就清空了查询中的所有排序项。 </font><font id="121">你也可以在其中使用 <tt class="docutils literal"><span class="pre">data</span></tt>&nbsp;，这样并不会有副作用，这是因为查询分组中只有这么一个角色了。</font></p>
<p><font id="122">这个行为与查询集文档中提到的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.distinct" title="django.db.models.query.QuerySet.distinct"><tt class="xref py py-meth docutils literal"><span class="pre">distinct()</span></tt></a> 一样，而且生成规则也一样：一般情况下，你不想在结果中由额外的字段扮演这个角色，那就清空排序项，或是至少保证它仅能访问 <tt class="docutils literal"><span class="pre">values()</span></tt>中的字段。</font></p>
<div class="admonition note">
<p class="first admonition-title"><font id="123">注意</font></p>
<p class="last"><font id="124">你可能想知道为什么 Django 不删除与你无关的列。</font><font id="125">主要原因就是要保证使用 <tt class="docutils literal"><span class="pre">distinct()</span></tt>和其他方法的一致性。Django &nbsp;<strong>永远不会</strong> 删除你所指定的排序限制(我们不能改动那些方法的行为，因为这会违背 <a class="reference internal" href="http://python.usyiyi.cn/django/misc/api-stability.html"><em>API stability</em></a> 原则)。</font></p>
</div>
</div>
</div>
<div class="section" id="s-aggregating-annotations">
<span id="aggregating-annotations"></span><h3><font id="142">聚合注解</font><a class="headerlink" href="aggregation.html#aggregating-annotations" title="Permalink to this headline">¶</a></h3>
<p><font id="126">你也可以在注解的结果上生成聚合。 </font><font id="127">当你定义一个 &nbsp;<tt class="docutils literal"><span class="pre">aggregate()</span></tt> 子句时，你提供的聚合会引用定义的任何别名做为查询中 <tt class="docutils literal"><span class="pre">annotate()</span></tt> 子句的一部分。</font></p>
<p><font id="128">例如，如果你想计算每本书平均有几个作者，你先用作者总数注解图书集，然后再聚合作者总数，引入注解字段：</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span><span class="p">,</span> <span class="n">Avg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">num_authors</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'authors'</span><span class="p">))</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Avg</span><span class="p">(</span><span class="s">'num_authors'</span><span class="p">))</span>
<span class="go">{'num_authors__avg': 1.66}</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="yui-b" id="sidebar">
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<h3><font id="143">目录</font></h3>
<ul>
<li><a class="reference internal" href="aggregation.html#"><font id="153">聚合</font></a><ul>
<li><a class="reference internal" href="aggregation.html#cheat-sheet"><font id="154">速查表</font></a></li>
<li><a class="reference internal" href="aggregation.html#generating-aggregates-over-a-queryset"><font id="155">在查询集上生成聚合</font></a></li>
<li><a class="reference internal" href="aggregation.html#generating-aggregates-for-each-item-in-a-queryset"><font id="156">为查询集的每一项生成聚合</font></a></li>
<li><a class="reference internal" href="aggregation.html#joins-and-aggregates"><font id="157">连接和聚合</font></a><ul>
<li><a class="reference internal" href="aggregation.html#following-relationships-backwards"><font id="158">遵循反向关系</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="aggregation.html#aggregations-and-other-queryset-clauses"><font id="159">聚合和其他查询集子句</font></a><ul>
<li><a class="reference internal" href="aggregation.html#filter-and-exclude"><font id="160"><tt class="docutils literal"><span class="pre">filter()</span></tt> 和<tt class="docutils literal"><span class="pre">exclude()</span></tt></font></a><ul>
<li><a class="reference internal" href="aggregation.html#filtering-on-annotations"><font id="161">对注解过滤</font></a></li>
<li><a class="reference internal" href="aggregation.html#order-of-annotate-and-filter-clauses"><font id="162"><tt class="docutils literal"><span class="pre">annotate()</span></tt> 和<tt class="docutils literal"><span class="pre">filter()</span></tt> 子句的顺序</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="aggregation.html#order-by"><font id="163">order_by()</font></a></li>
<li><a class="reference internal" href="aggregation.html#values"><font id="164">values()</font></a><ul>
<li><a class="reference internal" href="aggregation.html#order-of-annotate-and-values-clauses"><font id="165"><tt class="docutils literal"><span class="pre">annotate()</span></tt> 和<tt class="docutils literal"><span class="pre">values()</span></tt> 子句的顺序</font></a></li>
<li><a class="reference internal" href="aggregation.html#interaction-with-default-ordering-or-order-by"><font id="166">与默认的次序或<tt class="docutils literal"><span class="pre">order_by()</span></tt>交互</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="aggregation.html#aggregating-annotations"><font id="167">聚合注解</font></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><font id="144">浏览</font></h3>
<ul>
<li><font id="168">上一页：<a href="queries.html">查询</a></font></li>
<li><font id="169">下一页：<a href="managers.html">管理器</a></font></li>
</ul>
<h3><font id="145">你在这里：</font></h3>
<ul>
<li>
<a href="../../index.html"><font id="170">Django 1.8.2 文档</font></a>
<ul><li><a href="../index.html"><font id="171">使用 Django</font></a>
<ul><li><a href="index.html"><font id="172">模型和数据库</font></a>
<ul><li><font id="173">聚合</font></li></ul>
</li></ul></li></ul>
</li>
</ul>
<h3><font id="146">本页</font></h3>
<ul class="this-page-menu">
<li><a href="http://python.usyiyi.cn/django/_sources/topics/db/aggregation.txt" rel="nofollow"><font id="174">Show Source</font></a></li>
</ul>
<div id="searchbox" style="display: none">
<h3><font id="147">Quick search</font></h3>
<form action="http://python.usyiyi.cn/django/search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<p class="searchtip" style="font-size: 90%"><font id="129"> Enter search terms or a module, class or function name. </font></p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<h3><font id="148">最后更新：</font></h3>
<p class="topless"><font id="130">May 13, 2015</font></p>
</div>
</div>
<div id="ft">
<div class="nav">
    « <a href="queries.html" title="Making queries">previous</a>
     |
    <a accesskey="U" href="../index.html" title="Using Django">up</a>
   |
    <a href="managers.html" title="Managers">next</a> »</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div id="disqus_thread"></div><br>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'djangocn'; // required: replace example with your forum shortname
    var disqus_identifier = '/django/topics/db/aggregation';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<link href="http://python.usyiyi.cn/django/_static/ms_translator.css" rel="stylesheet" type="text/css"/>
<script src="http://python.usyiyi.cn/django/_static/ms_translator.js" type="text/javascript"></script>
<script src="http://python.usyiyi.cn/django/_static/jquery-ui-1.9.2.custom.min.js" type="text/javascript"></script>
<div id="MicrosoftTranslator" style="display:none; position: absolute; z-index: 2147483647; margin: 0px; border: 2px solid rgb(210, 210, 210); padding: 0px; color: rgb(0, 0, 0); background-color: rgb(230, 230, 230); font-family: Arial,Helvetica,Sans-Serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 12px; line-height: normal; direction: ltr; text-align: left; left: 274px; top: 2048.03px; min-width: 400px;">
    <div id="MSTCClose" style="float: right;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/tooltip_close.gif">
      </a>
    </div>
    
    <div id="MSTCPopDown" style="float: right;" style="display: none;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/popdown.gif">
      </a>
    </div>
    <div id="MSTCPopUP" style="float: right;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/popup.gif">
      </a>
    </div>
    
    <div id="MSTCTitle" style="margin: 4px 4px 8px; font-weight: bold;">原文
    </div>
    
    <div style="direction: ltr; text-align: left;">
      <span id="MSTCOrigion" style="display: inline-block; margin: 0px 4px 4px;"> </span>
    </div>
    
    <div id="MicrosoftTranslatorCommunity" class="MSTCltr">
      <div id="MSTCContent">
        <a id="MSTCExpandLink">
          <span id="MSTCImprove">改进翻译</span>
          <span id="MSTCSuggest">最小化</span>
          <img src="http://python.usyiyi.cn/django/_static/ctftoggledown.gif" id="MSTCToggleDown">
          <img src="http://python.usyiyi.cn/django/_static/ctftoggleup.gif" id="MSTCToggleUp">
        </a>
        <div id="MSTCRootPanel">
          <span id="MSTCLoading" style="display: none;">正在加载...</span>
          <div style="display: none;" id="MSTCTransPanelError">
            <div class="MSTCTableRow">
              <div class="MSTCTransPanelExc MSTCTableCell">
                <img style="border-width:0px;" src="http://python.usyiyi.cn/django/_static/error_exclamation.gif" id="ExclamationImage">
              </div>
              <div class="MSTCTableCell">
                <span id="MSTCTransPanelErrorMsg"></span>
              </div>
            </div>
            <div class="MSTCTableRow">
              <div class="MSTCTableCell"></div>
              <div class="MSTCTableCell MSTCFlipHoriz">
                <input type="image" style="border-width:0px;" src="http://python.usyiyi.cn/django/_static/error_OK.gif" class="MSTCErrorButtons" id="MSTCOKImgBtn" name="MSTCOKImgBtn">
              </div>
            </div>
          </div>
          
          <div id="MSTCTransPanel">
          </div>
          
          <div id="MSTCPrevNextPanel">
            <a id="MSTCPrevLink" style='border-right-width: 1px;border-right-style: solid;padding-right: 5px;'>
              <span>上一页</span>
            </a>
            <a style='color: black; border-right-width: 1px;border-right-style: solid;padding-right: 5px;'>
              <span>第</span>
              <span id="MSTCPage"></span>
              <span>页</span>
            </a>
            <a id="MSTCNextLink" style='padding-left: 5px;'>
              <span>下一页</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

</body>
</html>