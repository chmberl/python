<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Unicode 数据 — Django 1.8.2 中文文档</title>
<link href="../_static/default.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.8.2.dev20150513143415',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<link href="../index.html" rel="top" title="Django 1.8.2.dev20150513143415 documentation"/>
<link href="index.html" rel="up" title="API Reference"/>
<link href="urlresolvers.html" rel="next" title="django.core.urlresolvers utility functions"/>
<link href="template-response.html" rel="prev" title="TemplateResponse and SimpleTemplateResponse"/>
<script src="http://python.usyiyi.cn/django/templatebuiltins.js" type="text/javascript"></script>
<script type="text/javascript">
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='http://python.usyiyi.cn/django/ref/&quot;&#32;+&#32;base&#32;+&#32;&quot;#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='http://python.usyiyi.cn/django/ref/&quot;&#32;+&#32;base&#32;+&#32;&quot;#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);
</script>
</head>
<body>
<div class="document">
<div class="yui-t6" id="custom-doc">
<div id="hd">
<h1><font id="137">Django 1.8.2.dev20150513143415 documentation</font></h1>
<div id="global-nav">
<a href="../index.html" title="Home page">Home</a>  |
        <a href="../contents.html" title="Table of contents">Table of contents</a>  |
        <a href="../genindex.html" title="Global index">Index</a>  |
        <a href="../py-modindex.html" title="Module index">Modules</a>
</div>
<div class="nav">
    « <a href="template-response.html" title="TemplateResponse and SimpleTemplateResponse">previous</a>
     |
    <a accesskey="U" href="index.html" title="API Reference">up</a>
   |
    <a href="urlresolvers.html" title='&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django.core.urlresolvers&lt;/span&gt;&lt;/tt&gt; utility functions'>next</a> »</div>
</div>
<div id="bd">
<div id="yui-main">
<div class="yui-b">
<div class="yui-g" id="ref-unicode">
<div class="section" id="s-unicode-data">
<span id="unicode-data"></span><h1><font id="138">Unicode data</font><a class="headerlink" href="unicode.html#unicode-data" title="Permalink to this headline">¶</a></h1>
<p><font id="1">Django natively supports Unicode data everywhere. </font><font id="2">Providing your database can somehow store the data, you can safely pass around Unicode strings to templates, models and the database.</font></p>
<p><font id="3">This document tells you what you need to know if you’re writing applications that use data or templates that are encoded in something other than ASCII.</font></p>
<div class="section" id="s-creating-the-database">
<span id="creating-the-database"></span><h2><font id="139">Creating the database</font><a class="headerlink" href="unicode.html#creating-the-database" title="Permalink to this headline">¶</a></h2>
<p><font id="4">Make sure your database is configured to be able to store arbitrary string data. </font><font id="5">Normally, this means giving it an encoding of UTF-8 or UTF-16. </font><font id="6">If you use a more restrictive encoding – for example, latin1 (iso8859-1) – you won’t be able to store certain characters in the database, and information will be lost.</font></p>
<ul class="simple">
<li><font id="159">MySQL users, refer to the <a class="reference external" href="http://dev.mysql.com/doc/refman/5.6/en/charset-database.html">MySQL manual</a> for details on how to set or alter the database character set encoding.</font></li>
<li><font id="160">PostgreSQL users, refer to the <a class="reference external" href="http://www.postgresql.org/docs/current/static/multibyte.html">PostgreSQL manual</a> (section 22.3.2 in PostgreSQL 9) for details on creating databases with the correct encoding.</font></li>
<li><font id="161">SQLite users, there is nothing you need to do. </font><font id="162">SQLite always uses UTF-8 for internal encoding.</font></li>
</ul>
<p><font id="7">All of Django’s database backends automatically convert Unicode strings into the appropriate encoding for talking to the database. </font><font id="8">They also automatically convert strings retrieved from the database into Python Unicode strings. </font><font id="9">You don’t even need to tell Django what encoding your database uses: that is handled transparently.</font></p>
<p><font id="10">For more, see the section “The database API” below.</font></p>
</div>
<div class="section" id="s-general-string-handling">
<span id="general-string-handling"></span><h2><font id="140">General string handling</font><a class="headerlink" href="unicode.html#general-string-handling" title="Permalink to this headline">¶</a></h2>
<p><font id="11">Whenever you use strings with Django – e.g., in database lookups, template rendering or anywhere else – you have two choices for encoding those strings. </font><font id="12">You can use Unicode strings, or you can use normal strings (sometimes called “bytestrings”) that are encoded using UTF-8.</font></p>
<p><font id="13">In Python 3, the logic is reversed, that is normal strings are Unicode, and when you want to specifically create a bytestring, you have to prefix the string with a ‘b’. </font><font id="14">As we are doing in Django code from version 1.5, we recommend that you import <tt class="docutils literal"><span class="pre">unicode_literals</span></tt> from the __future__ library in your code. </font><font id="15">Then, when you specifically want to create a bytestring literal, prefix the string with ‘b’.</font></p>
<p><font id="16">Python 2 legacy:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">my_string</span> <span class="o">=</span> <span class="s">"This is a bytestring"</span>
<span class="n">my_unicode</span> <span class="o">=</span> <span class="s">u"This is an Unicode string"</span>
</pre></div>
</div>
<p><font id="17">Python 2 with unicode literals or Python 3:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="n">my_string</span> <span class="o">=</span> <span class="n">b</span><span class="s">"This is a bytestring"</span>
<span class="n">my_unicode</span> <span class="o">=</span> <span class="s">"This is an Unicode string"</span>
</pre></div>
</div>
<p><font id="18">See also <a class="reference internal" href="../topics/python3.html"><em>Python 3 compatibility</em></a>.</font></p>
<div class="admonition warning">
<p class="first admonition-title"><font id="19">Warning</font></p>
<p><font id="20">A bytestring does not carry any information with it about its encoding. </font><font id="21">For that reason, we have to make an assumption, and Django assumes that all bytestrings are in UTF-8.</font></p>
<p class="last"><font id="22">If you pass a string to Django that has been encoded in some other format, things will go wrong in interesting ways. </font><font id="23">Usually, Django will raise a <tt class="docutils literal"><span class="pre">UnicodeDecodeError</span></tt> at some point.</font></p>
</div>
<p><font id="24">If your code only uses ASCII data, it’s safe to use your normal strings, passing them around at will, because ASCII is a subset of UTF-8.</font></p>
<p><font id="25">Don’t be fooled into thinking that if your <a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> setting is set to something other than <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> you can use that other encoding in your bytestrings! </font><font id="26"><a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> only applies to the strings generated as the result of template rendering (and email). </font><font id="27">Django will always assume UTF-8 encoding for internal bytestrings. </font><font id="28">The reason for this is that the <a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> setting is not actually under your control (if you are the application developer). </font><font id="29">It’s under the control of the person installing and using your application – and if that person chooses a different setting, your code must still continue to work. </font><font id="30">Ergo, it cannot rely on that setting.</font></p>
<p><font id="31">In most cases when Django is dealing with strings, it will convert them to Unicode strings before doing anything else. </font><font id="32">So, as a general rule, if you pass in a bytestring, be prepared to receive a Unicode string back in the result.</font></p>
<div class="section" id="s-translated-strings">
<span id="translated-strings"></span><h3><font id="146">Translated strings</font><a class="headerlink" href="unicode.html#translated-strings" title="Permalink to this headline">¶</a></h3>
<p><font id="33">Aside from Unicode strings and bytestrings, there’s a third type of string-like object you may encounter when using Django. </font><font id="34">The framework’s internationalization features introduce the concept of a “lazy translation” – a string that has been marked as translated but whose actual translation result isn’t determined until the object is used in a string. </font><font id="35">This feature is useful in cases where the translation locale is unknown until the string is used, even though the string might have originally been created when the code was first imported.</font></p>
<p><font id="36">Normally, you won’t have to worry about lazy translations. </font><font id="37">Just be aware that if you examine an object and it claims to be a <tt class="docutils literal"><span class="pre">django.utils.functional.__proxy__</span></tt> object, it is a lazy translation. </font><font id="38">Calling <tt class="docutils literal"><span class="pre">unicode()</span></tt> with the lazy translation as the argument will generate a Unicode string in the current locale.</font></p>
<p><font id="39">For more details about lazy translation objects, refer to the <a class="reference internal" href="../topics/i18n/index.html"><em>internationalization</em></a> documentation.</font></p>
</div>
<div class="section" id="s-useful-utility-functions">
<span id="useful-utility-functions"></span><h3><font id="147">Useful utility functions</font><a class="headerlink" href="unicode.html#useful-utility-functions" title="Permalink to this headline">¶</a></h3>
<p><font id="40">Because some string operations come up again and again, Django ships with a few useful functions that should make working with Unicode and bytestring objects a bit easier.</font></p>
<div class="section" id="s-conversion-functions">
<span id="conversion-functions"></span><h4><font id="157">Conversion functions</font><a class="headerlink" href="unicode.html#conversion-functions" title="Permalink to this headline">¶</a></h4>
<p><font id="41">The <tt class="docutils literal"><span class="pre">django.utils.encoding</span></tt> module contains a few functions that are handy for converting back and forth between Unicode and bytestrings.</font></p>
<ul>
<li><p class="first"><font id="42"><tt class="docutils literal"><span class="pre">smart_text(s,</span> <span class="pre">encoding='utf-8',</span> <span class="pre">strings_only=False,</span> <span class="pre">errors='strict')</span></tt> converts its input to a Unicode string. </font><font id="43">The <tt class="docutils literal"><span class="pre">encoding</span></tt> parameter specifies the input encoding. </font><font id="44">(For example, Django uses this internally when processing form input data, which might not be UTF-8 encoded.) </font><font id="45">The <tt class="docutils literal"><span class="pre">strings_only</span></tt> parameter, if set to True, will result in Python numbers, booleans and <tt class="docutils literal"><span class="pre">None</span></tt> not being converted to a string (they keep their original types). </font><font id="46">The <tt class="docutils literal"><span class="pre">errors</span></tt> parameter takes any of the values that are accepted by Python’s <tt class="docutils literal"><span class="pre">unicode()</span></tt> function for its error handling.</font></p>
<p><font id="47">If you pass <tt class="docutils literal"><span class="pre">smart_text()</span></tt> an object that has a <tt class="docutils literal"><span class="pre">__unicode__</span></tt> method, it will use that method to do the conversion.</font></p>
</li>
<li><p class="first"><font id="48"><tt class="docutils literal"><span class="pre">force_text(s,</span> <span class="pre">encoding='utf-8',</span> <span class="pre">strings_only=False,</span> <span class="pre">errors='strict')</span></tt> is identical to <tt class="docutils literal"><span class="pre">smart_text()</span></tt> in almost all cases. </font><font id="49">The difference is when the first argument is a <a class="reference internal" href="../topics/i18n/translation.html#lazy-translations"><em>lazy translation</em></a> instance. </font><font id="50">While <tt class="docutils literal"><span class="pre">smart_text()</span></tt> preserves lazy translations, <tt class="docutils literal"><span class="pre">force_text()</span></tt> forces those objects to a Unicode string (causing the translation to occur). </font><font id="51">Normally, you’ll want to use <tt class="docutils literal"><span class="pre">smart_text()</span></tt>. </font><font id="52">However, <tt class="docutils literal"><span class="pre">force_text()</span></tt> is useful in template tags and filters that absolutely <em>must</em> have a string to work with, not just something that can be converted to a string.</font></p>
</li>
<li><p class="first"><font id="53"><tt class="docutils literal"><span class="pre">smart_bytes(s,</span> <span class="pre">encoding='utf-8',</span> <span class="pre">strings_only=False,</span> <span class="pre">errors='strict')</span></tt> is essentially the opposite of <tt class="docutils literal"><span class="pre">smart_text()</span></tt>. </font><font id="54">It forces the first argument to a bytestring. </font><font id="55">The <tt class="docutils literal"><span class="pre">strings_only</span></tt> parameter has the same behavior as for <tt class="docutils literal"><span class="pre">smart_text()</span></tt> and <tt class="docutils literal"><span class="pre">force_text()</span></tt>. </font><font id="56">This is slightly different semantics from Python’s builtin <tt class="docutils literal"><span class="pre">str()</span></tt> function, but the difference is needed in a few places within Django’s internals.</font></p>
</li>
</ul>
<p><font id="57">Normally, you’ll only need to use <tt class="docutils literal"><span class="pre">smart_text()</span></tt>. </font><font id="58">Call it as early as possible on any input data that might be either Unicode or a bytestring, and from then on, you can treat the result as always being Unicode.</font></p>
</div>
<div class="section" id="s-uri-and-iri-handling">
<span id="s-id1"></span><span id="uri-and-iri-handling"></span><span id="id1"></span><h4><font id="158">URI and IRI handling</font><a class="headerlink" href="unicode.html#uri-and-iri-handling" title="Permalink to this headline">¶</a></h4>
<p><font id="59">Web frameworks have to deal with URLs (which are a type of <a class="reference external" href="http://www.ietf.org/rfc/rfc3987.txt">IRI</a>). </font><font id="60">One requirement of URLs is that they are encoded using only ASCII characters. </font><font id="61">However, in an international environment, you might need to construct a URL from an <a class="reference external" href="http://www.ietf.org/rfc/rfc3987.txt">IRI</a> – very loosely speaking, a <a class="reference external" href="http://www.ietf.org/rfc/rfc2396.txt">URI</a> that can contain Unicode characters. </font><font id="62">Quoting and converting an IRI to URI can be a little tricky, so Django provides some assistance.</font></p>
<ul class="simple">
<li><font id="163">The function <a class="reference internal" href="http://python.usyiyi.cn/django/ref/utils.html#django.utils.encoding.iri_to_uri" title="django.utils.encoding.iri_to_uri"><tt class="xref py py-func docutils literal"><span class="pre">django.utils.encoding.iri_to_uri()</span></tt></a> implements the conversion from IRI to URI as required by the specification (<span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc3987.html#section-3.1"><strong>RFC 3987</strong></a>).</font></li>
<li><font id="164">The functions <a class="reference internal" href="http://python.usyiyi.cn/django/ref/utils.html#django.utils.http.urlquote" title="django.utils.http.urlquote"><tt class="xref py py-func docutils literal"><span class="pre">django.utils.http.urlquote()</span></tt></a> and <a class="reference internal" href="http://python.usyiyi.cn/django/ref/utils.html#django.utils.http.urlquote_plus" title="django.utils.http.urlquote_plus"><tt class="xref py py-func docutils literal"><span class="pre">django.utils.http.urlquote_plus()</span></tt></a> are versions of Python’s standard <tt class="docutils literal"><span class="pre">urllib.quote()</span></tt> and <tt class="docutils literal"><span class="pre">urllib.quote_plus()</span></tt> that work with non-ASCII characters. </font><font id="165">(The data is converted to UTF-8 prior to encoding.)</font></li>
</ul>
<p><font id="63">These two groups of functions have slightly different purposes, and it’s important to keep them straight. </font><font id="64">Normally, you would use <tt class="docutils literal"><span class="pre">urlquote()</span></tt> on the individual portions of the IRI or URI path so that any reserved characters such as ‘&amp;’ or ‘%’ are correctly encoded. </font><font id="65">Then, you apply <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> to the full IRI and it converts any non-ASCII characters to the correct encoded values.</font></p>
<div class="admonition note">
<p class="first admonition-title"><font id="66">Note</font></p>
<p class="last"><font id="67">Technically, it isn’t correct to say that <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> implements the full algorithm in the IRI specification. </font><font id="68">It doesn’t (yet) perform the international domain name encoding portion of the algorithm.</font></p>
</div>
<p><font id="69">The <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> function will not change ASCII characters that are otherwise permitted in a URL. </font><font id="70">So, for example, the character ‘%’ is not further encoded when passed to <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt>. </font><font id="71">This means you can pass a full URL to this function and it will not mess up the query string or anything like that.</font></p>
<p><font id="72">An example might clarify things here:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">urlquote</span><span class="p">(</span><span class="s">'Paris &amp; Orléans'</span><span class="p">)</span>
<span class="go">'Paris%20%26%20Orl%C3%A9ans'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iri_to_uri</span><span class="p">(</span><span class="s">'/favorites/François/</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">urlquote</span><span class="p">(</span><span class="s">'Paris &amp; Orléans'</span><span class="p">))</span>
<span class="go">'/favorites/Fran%C3%A7ois/Paris%20%26%20Orl%C3%A9ans'</span>
</pre></div>
</div>
<p><font id="73">If you look carefully, you can see that the portion that was generated by <tt class="docutils literal"><span class="pre">urlquote()</span></tt> in the second example was not double-quoted when passed to <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt>. </font><font id="74">This is a very important and useful feature. </font><font id="75">It means that you can construct your IRI without worrying about whether it contains non-ASCII characters and then, right at the end, call <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> on the result.</font></p>
<p><font id="76">Similarly, Django provides <a class="reference internal" href="http://python.usyiyi.cn/django/ref/utils.html#django.utils.encoding.uri_to_iri" title="django.utils.encoding.uri_to_iri"><tt class="xref py py-func docutils literal"><span class="pre">django.utils.encoding.uri_to_iri()</span></tt></a> which implements the conversion from URI to IRI as per <span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc3987.html#section-3.2"><strong>RFC 3987</strong></a>. </font><font id="77">It decodes all percent-encodings except those that don’t represent a valid UTF-8 sequence.</font></p>
<p><font id="78">An example to demonstrate:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">uri_to_iri</span><span class="p">(</span><span class="s">'/</span><span class="si">%E</span><span class="s">2</span><span class="si">%99%</span><span class="s">A5</span><span class="si">%E</span><span class="s">2</span><span class="si">%99%</span><span class="s">A5/?utf8=</span><span class="si">%E</span><span class="s">2%9C%93'</span><span class="p">)</span>
<span class="go">'/♥♥/?utf8=✓'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uri_to_iri</span><span class="p">(</span><span class="s">'%A9helloworld'</span><span class="p">)</span>
<span class="go">'%A9helloworld'</span>
</pre></div>
</div>
<p><font id="79">In the first example, the UTF-8 characters and reserved characters are unquoted. </font><font id="80">In the second, the percent-encoding remains unchanged because it lies outside the valid UTF-8 range.</font></p>
<p><font id="81">Both <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> and <tt class="docutils literal"><span class="pre">uri_to_iri()</span></tt> functions are idempotent, which means the following is always true:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">iri_to_uri</span><span class="p">(</span><span class="n">iri_to_uri</span><span class="p">(</span><span class="n">some_string</span><span class="p">))</span> <span class="o">==</span> <span class="n">iri_to_uri</span><span class="p">(</span><span class="n">some_string</span><span class="p">)</span>
<span class="n">uri_to_iri</span><span class="p">(</span><span class="n">uri_to_iri</span><span class="p">(</span><span class="n">some_string</span><span class="p">))</span> <span class="o">==</span> <span class="n">uri_to_iri</span><span class="p">(</span><span class="n">some_string</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="82">So you can safely call it multiple times on the same URI/IRI without risking double-quoting problems.</font></p>
</div>
</div>
</div>
<div class="section" id="s-models">
<span id="models"></span><h2><font id="141">Models</font><a class="headerlink" href="unicode.html#models" title="Permalink to this headline">¶</a></h2>
<p><font id="83">Because all strings are returned from the database as Unicode strings, model fields that are character based (CharField, TextField, URLField, etc) will contain Unicode values when Django retrieves data from the database. </font><font id="84">This is <em>always</em> the case, even if the data could fit into an ASCII bytestring.</font></p>
<p><font id="85">You can pass in bytestrings when creating a model or populating a field, and Django will convert it to Unicode when it needs to.</font></p>
<div class="section" id="s-choosing-between-str-and-unicode">
<span id="choosing-between-str-and-unicode"></span><h3><font id="148">Choosing between </font><tt class="docutils literal"><span class="pre">__str__()</span></tt></h3>
<div class="admonition note">
<p class="first admonition-title"><font id="86">Note</font></p>
<p class="last"><font id="87">If you are on Python 3, you can skip this section because you’ll always create <tt class="docutils literal"><span class="pre">__str__()</span></tt> rather than <tt class="docutils literal"><span class="pre">__unicode__()</span></tt>. </font><font id="88">If you’d like compatibility with Python 2, you can decorate your model class with <a class="reference internal" href="http://python.usyiyi.cn/django/ref/utils.html#django.utils.encoding.python_2_unicode_compatible" title="django.utils.encoding.python_2_unicode_compatible"><tt class="xref py py-func docutils literal"><span class="pre">python_2_unicode_compatible()</span></tt></a>.</font></p>
</div>
<p><font id="89">One consequence of using Unicode by default is that you have to take some care when printing data from the model.</font></p>
<p><font id="90">In particular, rather than giving your model a <tt class="docutils literal"><span class="pre">__str__()</span></tt> method, we recommended you implement a <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> method. </font><font id="91">In the <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> method, you can quite safely return the values of all your fields without having to worry about whether they fit into a bytestring or not. </font><font id="92">(The way Python works, the result of <tt class="docutils literal"><span class="pre">__str__()</span></tt> is <em>always</em> a bytestring, even if you accidentally try to return a Unicode object).</font></p>
<p><font id="93">You can still create a <tt class="docutils literal"><span class="pre">__str__()</span></tt> method on your models if you want, of course, but you shouldn’t need to do this unless you have a good reason. </font><font id="94">Django’s <tt class="docutils literal"><span class="pre">Model</span></tt> base class automatically provides a <tt class="docutils literal"><span class="pre">__str__()</span></tt> implementation that calls <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> and encodes the result into UTF-8. </font><font id="95">This means you’ll normally only need to implement a <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> method and let Django handle the coercion to a bytestring when required.</font></p>
</div>
<div class="section" id="s-taking-care-in-get-absolute-url">
<span id="taking-care-in-get-absolute-url"></span><h3><font id="149">Taking care in </font><tt class="docutils literal"><span class="pre">get_absolute_url()</span></tt></h3>
<p><font id="96">URLs can only contain ASCII characters. </font><font id="97">If you’re constructing a URL from pieces of data that might be non-ASCII, be careful to encode the results in a way that is suitable for a URL. </font><font id="98">The <a class="reference internal" href="urlresolvers.html#django.core.urlresolvers.reverse" title="django.core.urlresolvers.reverse"><tt class="xref py py-func docutils literal"><span class="pre">reverse()</span></tt></a> function handles this for you automatically.</font></p>
<p><font id="99">If you’re constructing a URL manually (i.e., <em>not</em> using the <tt class="docutils literal"><span class="pre">reverse()</span></tt> function), you’ll need to take care of the encoding yourself. </font><font id="100">In this case, use the <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> and <tt class="docutils literal"><span class="pre">urlquote()</span></tt> functions that were documented <a class="reference internal" href="unicode.html#id1">above</a>. </font><font id="101">For example:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.utils.encoding</span> <span class="kn">import</span> <span class="n">iri_to_uri</span>
<span class="kn">from</span> <span class="nn">django.utils.http</span> <span class="kn">import</span> <span class="n">urlquote</span>

<span class="k">def</span> <span class="nf">get_absolute_url</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">'/person/</span><span class="si">%s</span><span class="s">/?x=0&amp;y=0'</span> <span class="o">%</span> <span class="n">urlquote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iri_to_uri</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="102">This function returns a correctly encoded URL even if <tt class="docutils literal"><span class="pre">self.location</span></tt> is something like “Jack visited Paris &amp; Orléans”. </font><font id="103">(In fact, the <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> call isn’t strictly necessary in the above example, because all the non-ASCII characters would have been removed in quoting in the first line.)</font></p>
</div>
</div>
<div class="section" id="s-the-database-api">
<span id="the-database-api"></span><h2><font id="142">The database API</font><a class="headerlink" href="unicode.html#the-database-api" title="Permalink to this headline">¶</a></h2>
<p><font id="104">You can pass either Unicode strings or UTF-8 bytestrings as arguments to <tt class="docutils literal"><span class="pre">filter()</span></tt> methods and the like in the database API. </font><font id="105">The following two querysets are identical:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="n">qs</span> <span class="o">=</span> <span class="n">People</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">'Å'</span><span class="p">)</span>
<span class="n">qs</span> <span class="o">=</span> <span class="n">People</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="n">b</span><span class="s">'</span><span class="se">\xc3\x85</span><span class="s">'</span><span class="p">)</span> <span class="c"># UTF-8 encoding of Å</span>
</pre></div>
</div>
</div>
<div class="section" id="s-templates">
<span id="templates"></span><h2><font id="143">Templates</font><a class="headerlink" href="unicode.html#templates" title="Permalink to this headline">¶</a></h2>
<p><font id="106">You can use either Unicode or bytestrings when creating templates manually:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">django.template</span> <span class="kn">import</span> <span class="n">Template</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="n">b</span><span class="s">'This is a bytestring template.'</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s">'This is a Unicode template.'</span><span class="p">)</span>
</pre></div>
</div>
<p><font id="107">But the common case is to read templates from the filesystem, and this creates a slight complication: not all filesystems store their data encoded as UTF-8. </font><font id="108">If your template files are not stored with a UTF-8 encoding, set the <a class="reference internal" href="settings.html#std:setting-FILE_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">FILE_CHARSET</span></tt></a> setting to the encoding of the files on disk. </font><font id="109">When Django reads in a template file, it will convert the data from this encoding to Unicode. </font><font id="110">(<a class="reference internal" href="settings.html#std:setting-FILE_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">FILE_CHARSET</span></tt></a> is set to <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> by default.)</font></p>
<p><font id="111">The <a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> setting controls the encoding of rendered templates. </font><font id="112">This is set to UTF-8 by default.</font></p>
<div class="section" id="s-template-tags-and-filters">
<span id="template-tags-and-filters"></span><h3><font id="150">Template tags and filters</font><a class="headerlink" href="unicode.html#template-tags-and-filters" title="Permalink to this headline">¶</a></h3>
<p><font id="113">A couple of tips to remember when writing your own template tags and filters:</font></p>
<ul class="simple">
<li><font id="166">Always return Unicode strings from a template tag’s <tt class="docutils literal"><span class="pre">render()</span></tt> method and from template filters.</font></li>
<li><font id="167">Use <tt class="docutils literal"><span class="pre">force_text()</span></tt> in preference to <tt class="docutils literal"><span class="pre">smart_text()</span></tt> in these places. </font><font id="168">Tag rendering and filter calls occur as the template is being rendered, so there is no advantage to postponing the conversion of lazy translation objects into strings. </font><font id="169">It’s easier to work solely with Unicode strings at that point.</font></li>
</ul>
</div>
</div>
<div class="section" id="s-email">
<span id="email"></span><h2><font id="144">Email</font><a class="headerlink" href="unicode.html#email" title="Permalink to this headline">¶</a></h2>
<p><font id="114">Django’s email framework (in <tt class="docutils literal"><span class="pre">django.core.mail</span></tt>) supports Unicode transparently. </font><font id="115">You can use Unicode data in the message bodies and any headers. </font><font id="116">However, you’re still obligated to respect the requirements of the email specifications, so, for example, email addresses should use only ASCII characters.</font></p>
<p><font id="117">The following code example demonstrates that everything except email addresses can be non-ASCII:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">django.core.mail</span> <span class="kn">import</span> <span class="n">EmailMessage</span>

<span class="n">subject</span> <span class="o">=</span> <span class="s">'My visit to Sør-Trøndelag'</span>
<span class="n">sender</span> <span class="o">=</span> <span class="s">'Arnbjörg Ráðormsdóttir &lt;arnbjorg@example.com&gt;'</span>
<span class="n">recipients</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Fred &lt;fred@example.com'</span><span class="p">]</span>
<span class="n">body</span> <span class="o">=</span> <span class="s">'...'</span>
<span class="n">msg</span> <span class="o">=</span> <span class="n">EmailMessage</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">recipients</span><span class="p">)</span>
<span class="n">msg</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="s">"Une pièce jointe.pdf"</span><span class="p">,</span> <span class="s">"%PDF-1.4.%..."</span><span class="p">,</span> <span class="n">mimetype</span><span class="o">=</span><span class="s">"application/pdf"</span><span class="p">)</span>
<span class="n">msg</span><span class="o">.</span><span class="n">send</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-form-submission">
<span id="form-submission"></span><h2><font id="145">Form submission</font><a class="headerlink" href="unicode.html#form-submission" title="Permalink to this headline">¶</a></h2>
<p><font id="118">HTML form submission is a tricky area. </font><font id="119">There’s no guarantee that the submission will include encoding information, which means the framework might have to guess at the encoding of submitted data.</font></p>
<p><font id="120">Django adopts a “lazy” approach to decoding form data. </font><font id="121">The data in an <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> object is only decoded when you access it. </font><font id="122">In fact, most of the data is not decoded at all. </font><font id="123">Only the <tt class="docutils literal"><span class="pre">HttpRequest.GET</span></tt> and <tt class="docutils literal"><span class="pre">HttpRequest.POST</span></tt> data structures have any decoding applied to them. </font><font id="124">Those two fields will return their members as Unicode data. </font><font id="125">All other attributes and methods of <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> return data exactly as it was submitted by the client.</font></p>
<p><font id="126">By default, the <a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> setting is used as the assumed encoding for form data. </font><font id="127">If you need to change this for a particular form, you can set the <tt class="docutils literal"><span class="pre">encoding</span></tt> attribute on an <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> instance. </font><font id="128">For example:</font></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">some_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c"># We know that the data must be encoded as KOI8-R (for some reason).</span>
    <span class="n">request</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="s">'koi8-r'</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><font id="129">You can even change the encoding after having accessed <tt class="docutils literal"><span class="pre">request.</span></tt></font><font id="130">GET or <tt class="docutils literal"><span class="pre">request.</span></tt></font><font id="131">POST, and all subsequent accesses will use the new encoding.</font></p>
<p><font id="132">Most developers won’t need to worry about changing form encoding, but this is a useful feature for applications that talk to legacy systems whose encoding you cannot control.</font></p>
<p><font id="133">Django does not decode the data of file uploads, because that data is normally treated as collections of bytes, rather than strings. </font><font id="134">Any automatic decoding there would alter the meaning of the stream of bytes.</font></p>
</div>
</div>
</div>
</div>
</div>
<div class="yui-b" id="sidebar">
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<h3><font id="151">Table Of Contents</font></h3>
<ul>
<li><a class="reference internal" href="unicode.html#"><font id="170">Unicode data</font></a><ul>
<li><a class="reference internal" href="unicode.html#creating-the-database"><font id="171">Creating the database</font></a></li>
<li><a class="reference internal" href="unicode.html#general-string-handling"><font id="172">General string handling</font></a><ul>
<li><a class="reference internal" href="unicode.html#translated-strings"><font id="173">Translated strings</font></a></li>
<li><a class="reference internal" href="unicode.html#useful-utility-functions"><font id="174">Useful utility functions</font></a><ul>
<li><a class="reference internal" href="unicode.html#conversion-functions"><font id="175">Conversion functions</font></a></li>
<li><a class="reference internal" href="unicode.html#uri-and-iri-handling"><font id="176">URI and IRI handling</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="unicode.html#models"><font id="177">Models</font></a><ul>
<li><a class="reference internal" href="unicode.html#choosing-between-str-and-unicode"><font id="178">None</font></a></li>
<li><a class="reference internal" href="unicode.html#taking-care-in-get-absolute-url"><font id="179">None</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="unicode.html#the-database-api"><font id="180">The database API</font></a></li>
<li><a class="reference internal" href="unicode.html#templates"><font id="181">Templates</font></a><ul>
<li><a class="reference internal" href="unicode.html#template-tags-and-filters"><font id="182">Template tags and filters</font></a></li>
</ul>
</li>
<li><a class="reference internal" href="unicode.html#email"><font id="183">Email</font></a></li>
<li><a class="reference internal" href="unicode.html#form-submission"><font id="184">Form submission</font></a></li>
</ul>
</li>
</ul>
<h3><font id="152">Browse</font></h3>
<ul>
<li><font id="185">Prev: <a href="template-response.html">TemplateResponse and SimpleTemplateResponse</a></font></li>
<li><font id="186">Next: <a href="urlresolvers.html"><tt class="docutils literal"><span class="pre">django.core.urlresolvers</span></tt> utility functions</a></font></li>
</ul>
<h3><font id="153">You are here:</font></h3>
<ul>
<li>
<a href="../index.html"><font id="187">Django 1.8.2.dev20150513143415 documentation</font></a>
<ul><li><a href="index.html"><font id="188">API Reference</font></a>
<ul><li><font id="189">Unicode data</font></li></ul>
</li></ul>
</li>
</ul>
<h3><font id="154">This Page</font></h3>
<ul class="this-page-menu">
<li><a href="http://python.usyiyi.cn/django/_sources/ref/unicode.txt" rel="nofollow"><font id="190">Show Source</font></a></li>
</ul>
<div id="searchbox" style="display: none">
<h3><font id="155">Quick search</font></h3>
<form action="http://python.usyiyi.cn/django/search.html" class="search" method="get">
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<p class="searchtip" style="font-size: 90%"><font id="135"> Enter search terms or a module, class or function name. </font></p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<h3><font id="156">Last update:</font></h3>
<p class="topless"><font id="136">May 13, 2015</font></p>
</div>
</div>
<div id="ft">
<div class="nav">
    « <a href="template-response.html" title="TemplateResponse and SimpleTemplateResponse">previous</a>
     |
    <a accesskey="U" href="index.html" title="API Reference">up</a>
   |
    <a href="urlresolvers.html" title='&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django.core.urlresolvers&lt;/span&gt;&lt;/tt&gt; utility functions'>next</a> »</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div id="disqus_thread"></div><br>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'djangocn'; // required: replace example with your forum shortname
    var disqus_identifier = '/django/ref/unicode';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<link href="http://python.usyiyi.cn/django/_static/ms_translator.css" rel="stylesheet" type="text/css"/>
<script src="http://python.usyiyi.cn/django/_static/ms_translator.js" type="text/javascript"></script>
<script src="http://python.usyiyi.cn/django/_static/jquery-ui-1.9.2.custom.min.js" type="text/javascript"></script>
<div id="MicrosoftTranslator" style="display:none; position: absolute; z-index: 2147483647; margin: 0px; border: 2px solid rgb(210, 210, 210); padding: 0px; color: rgb(0, 0, 0); background-color: rgb(230, 230, 230); font-family: Arial,Helvetica,Sans-Serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 12px; line-height: normal; direction: ltr; text-align: left; left: 274px; top: 2048.03px; min-width: 400px;">
    <div id="MSTCClose" style="float: right;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/tooltip_close.gif">
      </a>
    </div>
    
    <div id="MSTCPopDown" style="float: right;" style="display: none;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/popdown.gif">
      </a>
    </div>
    <div id="MSTCPopUP" style="float: right;">
      <a style="display: inline-block; cursor: pointer; text-decoration: none; vertical-align: top; border: 0px none; padding: 4px;">
        <img src="http://python.usyiyi.cn/django/_static/popup.gif">
      </a>
    </div>
    
    <div id="MSTCTitle" style="margin: 4px 4px 8px; font-weight: bold;">原文
    </div>
    
    <div style="direction: ltr; text-align: left;">
      <span id="MSTCOrigion" style="display: inline-block; margin: 0px 4px 4px;"> </span>
    </div>
    
    <div id="MicrosoftTranslatorCommunity" class="MSTCltr">
      <div id="MSTCContent">
        <a id="MSTCExpandLink">
          <span id="MSTCImprove">改进翻译</span>
          <span id="MSTCSuggest">最小化</span>
          <img src="http://python.usyiyi.cn/django/_static/ctftoggledown.gif" id="MSTCToggleDown">
          <img src="http://python.usyiyi.cn/django/_static/ctftoggleup.gif" id="MSTCToggleUp">
        </a>
        <div id="MSTCRootPanel">
          <span id="MSTCLoading" style="display: none;">正在加载...</span>
          <div style="display: none;" id="MSTCTransPanelError">
            <div class="MSTCTableRow">
              <div class="MSTCTransPanelExc MSTCTableCell">
                <img style="border-width:0px;" src="http://python.usyiyi.cn/django/_static/error_exclamation.gif" id="ExclamationImage">
              </div>
              <div class="MSTCTableCell">
                <span id="MSTCTransPanelErrorMsg"></span>
              </div>
            </div>
            <div class="MSTCTableRow">
              <div class="MSTCTableCell"></div>
              <div class="MSTCTableCell MSTCFlipHoriz">
                <input type="image" style="border-width:0px;" src="http://python.usyiyi.cn/django/_static/error_OK.gif" class="MSTCErrorButtons" id="MSTCOKImgBtn" name="MSTCOKImgBtn">
              </div>
            </div>
          </div>
          
          <div id="MSTCTransPanel">
          </div>
          
          <div id="MSTCPrevNextPanel">
            <a id="MSTCPrevLink" style='border-right-width: 1px;border-right-style: solid;padding-right: 5px;'>
              <span>上一页</span>
            </a>
            <a style='color: black; border-right-width: 1px;border-right-style: solid;padding-right: 5px;'>
              <span>第</span>
              <span id="MSTCPage"></span>
              <span>页</span>
            </a>
            <a id="MSTCNextLink" style='padding-left: 5px;'>
              <span>下一页</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

</body>
</html>